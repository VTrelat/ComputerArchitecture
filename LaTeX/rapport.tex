\documentclass[11pt, a4 paper]{article}
\usepackage[french]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multicol}
\usepackage{circuitikz}
\usepackage{pgfplots}
\usepackage{framed}


\usetikzlibrary{babel}
\usetikzlibrary{backgrounds}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.92,0.92,0.95}

\newcommand{\halmos}{\hfill$\blacksquare$}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,     
    frame=single,    
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}

\begin{document}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .2\textwidth]{img/logoartem.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Architecture des ordinateurs}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Erwan LEBAILLY | Vilavane LY | Vincent TRÉLAT | Benjamin ZHU
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\tableofcontents
\pagebreak

\section{Chapitre 1}
\subsection{Exercice 1}
Avec la convention $0 \leftrightarrow \texttt{faux}$ et $1 \leftrightarrow \texttt{vrai}$, $0 \wedge 1 = \texttt{faux}$.

\subsection{Exercice 2}
On donne la table de $c_0$ :
\begin{center}
    $c_0 \colon$
    \begin{tabular}{||c | c | c ||} 
     \hline
     $a_0 \backslash b_0$ & 0 & 1 \\ [0.5ex] 
     \hline\hline
     0 & 0 & 1  \\ 
     \hline
     1 & 1 & 0 \\
     \hline
    \end{tabular}
\end{center}
On peut interpréter cette table comme la table de vérité du "ou exclusif", le \textit{xor}. Ainsi, $c_0$ coincide avec $a_0 \oplus b_0 = (a_0 \vee b_0) \wedge (\neg (a_0 \wedge b_0))$.

\subsection{Exercice 3}
a. Montrons que l'opérateur xor $\oplus$ est associatif et commutatif :\\
Soient $a, b, c \in \{0, 1\}$.\\

\textbf{Associativité :} on donne ci-dessous la table de vérité de $(a \oplus b) \oplus c$ et $a \oplus (b \oplus c)$:
\begin{center}
    \begin{tabular}{||c | c | c | c | c | c ||} 
     \hline
     $a$ & $b$ & $c$ & $a \oplus b$ & $(a \oplus b) \oplus c$ & $a \oplus (b \oplus c)$ \\ [0.5ex] 
     \hline\hline
    %a   b   c  a+b  r1 r2
     0 & 0 & 0 & 0 & 0 & 0\\ 
     0 & 0 & 1 & 0 & 1 & 1\\ 
     1 & 0 & 0 & 1 & 0 & 0\\ 
     1 & 0 & 1 & 1 & 0 & 0\\ 
     0 & 1 & 0 & 1 & 1 & 1\\ 
     0 & 1 & 1 & 1 & 0 & 0\\ 
     1 & 1 & 0 & 0 & 0 & 0\\ 
     1 & 1 & 1 & 0 & 1 & 1\\ 
     \hline
    \end{tabular}
\end{center}

\textbf{Commutativité :} on donne ci-dessous la table de vérité de $a \oplus b$ et $b \oplus a$:
\begin{center}
    \begin{tabular}{||c | c | c | c ||} 
     \hline
     $a$ & $b$ & $a \oplus b$ & $b \oplus a$ \\ [0.5ex] 
     \hline\hline
    %a   b  a+b  b+a
    0 & 0 & 0 & 0 \\
    0 & 1 & 1 & 1 \\
    1 & 0 & 1 & 1 \\
    1 & 1 & 0 & 0 \\
     \hline
    \end{tabular}
\end{center}

Enfin, $a \oplus a = 0$ et $a \oplus 0 = a$.\\

On peut maintenant montrer le résultat demandé :\\
\begin{equation*}
    d = a \oplus c = a \oplus (a \oplus b) = a \oplus a \oplus b = b
\end{equation*}

\begin{equation*}
    e = b \oplus c = b \oplus (a \oplus b) = b \oplus a \oplus b = a
\end{equation*}

\halmos

b. On donne ci-dessous le circuit correspondant :
\begin{center}
    \begin{circuitikz}[framed, scale=1.5]
        % \draw (0,0) node[ american and port ] {};
        % \draw (0,2) node[ american or port ] {};
        % \draw (0,6) node[ american not port ] {};
    
        \draw (0,1) node (a) {a};
        \draw (7,1) node (d) {d};
        \draw (0,-1) node (b) {b};
        \draw (7,-1) node (e) {e};
        \draw (3,0) node[ american xor port ] (xor1) {};
        \draw (6,1) node[ american xor port ] (xor2) {};
        \draw (6,-1) node[ american xor port ] (xor3) {};
        
        \draw (.2, 1) -- (xor1.in 1);
        \draw (.2, 1) -| (xor2.in 1);
        \draw (xor1.out) |- (xor2.in 2);
        \draw (xor1.out) |- (xor3.in 1);
        \draw (.2, -1) -- (xor1.in 2);
        \draw (.2, -1) -| (xor3.in 2);
        
        \draw (xor2.out) -| (6.8,1);
        \draw (xor3.out) -| (6.8,-1);
        
    \end{circuitikz}
\end{center}

\subsection{Exercice 4}
a. On écrit le code suivant :\\
\begin{lstlisting}[style=CStyle]
int main()
    {
        printf("Sizeof int: %lu octets\n", sizeof(int));
        printf("Sizeof short: %lu octets\n", sizeof(short));
        printf("Sizeof char: %lu octets\n", sizeof(char));
        return 0;
    }
\end{lstlisting}

La sortie est la suivante :\\
\begin{lstlisting}[style=CStyle]
    Sizeof int: 4 octets
    Sizeof short: 2 octets
    Sizeof char: 1 octets
\end{lstlisting}

b. On écrit le code suivant :
\begin{lstlisting}[style=CStyle]
int main()
    {
        int a = pow(2, 31);
        int b = pow(2, 31);
        int c = a + b;
        printf("%d\n", c);
        return 0;
    }
\end{lstlisting}

La sortie affiche 0, ce qui correspond bien à $2^{32} \mod(2^{32})$

\subsection{Exercice 5}
On donne ci-dessous l'écriture binaire sur 4 et 8 bits de 0, 1, -1 et -2:
\begin{center}
    \begin{tabular}{c | c | c} 
    $x$ & 4 bits & 8 bits\\
        \hline
        \hline
    0 :& 0000 & 0000 0000\\ 
    1 :& 0001 & 0000 0001\\
    -1 :& 1111 & 1111 1111\\
    -2 :& 1110 & 1111 1110\\
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. $m_1 = 0001$ et $m_{-1} = 1001$.

b. En abusant de la notation + pour des mots : $m_0 = m_1 + m_{-1} = 1010$.

c. En suivant la règle de signes, 1010 est l'encodage de -2.

\subsection{Exercice 7}
Soit $b$ un nombre de bits. Soit $x$ un entier relatif qu'on souhaite représenter sur $b$ bits.\\
Si $x \geq 0$, alors l'encodage de $x$ correspond à une écriture dans $[0, 2^{b-1}-1]$, alors cette écriture commence par un zéro (de 00...0 à 01...1). Si $x < 0$, alors $2^b - x \in [2^{b-1}, 2^b-1]$ (soit de 10...0 à 11...1), son écriture commence par un 1.

\halmos


\subsection{Exercice 8}
Dans le premier code, on dispose de 2 cases mémoires différentes. Le résultat affiché est -106 pour la valeur de d, ce qui est normal puisque d est signé.\\
Dans le deuxième code, on utilise une seule case mémoire à travers l'utilisation de deux pointeurs, un signé et un non signé. Le résultat affiché est identique au premier code.\\
Cela permet de montrer que la mémoire est "non typée", l'interprétation de la valeur mémoire dépend directement du type de l'objet qui lit cette valeur.

\subsection{Exercice 9}
a. 10 s'écrit $2\times5$ et toute puissance de 2 s'écrit $2^k$ où $k\in \mathbb{N}$.\\
Ainsi, si $x \in 2^{\mathbb{N}}$ (par abus de langage) est divisible par 10, alors $x$ contient au moins 2 et 5 dans sa décomposition en facteurs premiers, ce qui donne une contradition avec la propriété précédemment énoncée.\\

\halmos

b. Supposons que $0.1$ soit représentable sur $kl$ bits. Alors, d'après le résultat du cours, $2^l \times 0.1$ est un entier, autrement dit $2^l$ est divisible par 10. D'après la question précédente, c'est impossible.

\halmos

\subsection{Exercice 10}
L'écriture binaire approchée de $0.1$ est $0.0001~1001_2$, de valeur décimale $0.09765625$.

\subsection{Exercice 11}
a. On écrit la fonction suivante en C :

\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            printf("(%d, %d) : %s\n", i, j, (a+b == c)?"true":"false");
        }
    } 
    return 0;
}
\end{lstlisting}

La sortie affichée contient, entre autres, les résultats suivants :
\begin{multicols}{2}
    \begin{itemize}
        \item[$\bullet$] (1, 4) : true
        \item[$\bullet$] (1, 5) : true
        \item[$\bullet$] (1, 6) : false
        \item[$\bullet$] (1, 7) : true
        \item[$\bullet$] (1, 8) : false
        
        \item[$\bullet$] (3, 4) : false
        \item[$\bullet$] (3, 5) : true
        \item[$\bullet$] (3, 6) : false
        \item[$\bullet$] (3, 7) : true
        \item[$\bullet$] (3, 8) : true
    \end{itemize}    
\end{multicols}

b. On modifie seulement la ligne d'affichage dans le code\footnote{Comme un \texttt{int} est codé sur 4 octets, on donne 16 caractères à chaque affichage.} :
\begin{lstlisting}[style=CStyle]
printf("%.16f + %.16f = %.16f\n", a, b, c);
\end{lstlisting}
On donne seulement les résultats pour les 5 premiers couples ci-dessus :
\begin{lstlisting}[style=CStyle]
0.1000000014901161 + 0.4000000059604645 = 0.5000000000000000
0.1000000014901161 + 0.5000000000000000 = 0.6000000238418579
0.1000000014901161 + 0.6000000238418579 = 0.6999999880790710
0.1000000014901161 + 0.6999999880790710 = 0.8000000119209290
0.1000000014901161 + 0.8000000119209290 = 0.8999999761581421
\end{lstlisting}

c. On remarque que pour une addition, l'égalité \texttt{a+b==c} est vérifiée lorsque \texttt{a} et \texttt{b} sont représentables, ou quand l'un des deux seulement l'est. Dans le second cas, l'erreur de représentation n'a pas eu d'impact sur le résultat puisque c'est la seule erreur du calcul. Ainsi l'égalité reste vraie.\\
En revanche, dès que les deux flottants ne sont pas représentables, les erreurs s'accumulent et alors la représentation de \texttt{c} peut différer de la valeur de \texttt{a+b}.\\

Dans un cas général si on prend $x, y \in \mathbb{R}$ tels que $x=y$, on aura \texttt{x==y} quand $x$ et $y$ sont représentables sur un nombre de bits donné\footnote{Il faut tout de même faire attention à la précision. Augmenter la précision ne rendra pas les calculs exacts pour autant.}. Dans les autres cas, il est possible d'obtenir un résultat correct mais cela résulte plutôt du hasard.\\

d. On modifie la fonction précédente :
\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            if(a+b!=c){
                int m1 = a+b>c;
                int m2 = a+b+.000001>c+.000001;
                printf("(%d, %d) : %d %d\n", i, j, m1, m2);
            }
        }
    } 
    return 0;
}
\end{lstlisting}

On obtient la sortie suivante :
\begin{lstlisting}[style=CStyle]
// a+b > c is tested before and after adding 1e-6
(1, 6) : 1 1
(1, 8) : 1 1
(3, 4) : 1 1
(3, 6) : 1 1
(4, 3) : 1 1
(6, 1) : 1 1
(6, 3) : 1 1
(6, 8) : 1 1
(7, 9) : 0 0
(8, 1) : 1 1
(8, 6) : 1 1
(9, 7) : 0 0
\end{lstlisting}
On constate que l'ordre est conservé à chaque fois. Comme $10^{-6}$ n'est pas représentable sur 16 bits ($10^{-6} \approx 2^{-20}$), on simule l'effet de la propagation d'une erreur.\\
On en déduit que des erreurs successives d'arrondi ne bousculent pas l'ordre sur des valeurs arrondies. Toutefois ici on effectue le même calcul des deux côtés. On peut donc toujours les comparer\footnote{Pas l'égalité.}, même après plusieurs calculs, puisque l'ordre est conservé. On peut également penser que cela ne provoquera pas d'évolution chaotique ou aléatoire de ces valeurs dans les calculs. En revanche, pour une suite d'opérations inconnue, cela risque de devenir insignifiant de vouloir comparer deux flottants.

\subsection{Exercice 12}
On note $s_1 = \displaystyle{\sum_{i=1}^{k} \frac{1}{i}}$ et $s_2 = \displaystyle{\sum_{i=k}^{1} \frac{1}{i}}$.\\
On écrit la fonction suivante :

\begin{lstlisting}[style=CStyle]
int main() {
    float s1 = 0.0, s2 = 0.0;
    long k = 1000000000;
    for (double i = 1; i<k+1; i++){
        s1 += 1/i;
        s2 += 1/(k+1-i);
    }
    printf("k=%ld\n    s1 = %.16f\n    s2 = %.16f\n", k, s1, s2);
    return 0;
}
\end{lstlisting}

Les résultats sont les suivants :
\begin{lstlisting}[style=CStyle]
k=1000
    s1 = 7.4854784011840820
    s2 = 7.4854717254638672
k=1000000
    s1 = 14.3573579788208008
    s2 = 14.3926515579223633
k=1000000000
    s1 = 15.4036827087402344
    s2 = 18.8079185485839844
\end{lstlisting}
On constate que les résultats diffèrent\footnote{Même plus que ça, on dirait que la série converge ! On connait l'équivalent pour la série harmonique : $H_n \underset{n \to +\infty}{\sim} \gamma + \ln(n)$ où $\gamma \approx 0.5$ est la constante d'Euler. Pour $n = 10^9$, on devrait donc plutôt être autour de $H_n \approx 21$.} d'autant plus que le nombre d'erreurs successives est grand, ce qui n'est pas étonnant. Là où le résultat interpelle, c'est que l'ordre de parcours de la somme a un impact conséquent sur le résultat.\\
Cette erreur est due au fait que lorsque le parcours est décroissant, on finit pas les petits nombres. Ces derniers causent alors des erreurs d'arrondi car leur ordre de grandeur est faible par rapport aux premiers nombres.

\subsection{Exercice 13}
a. La taille d'un \texttt{float} en C est de 4 \textit{bytes}, soit 32 bits :
\begin{itemize}
    \item[$\bullet$] 1 bit de signe
    \item[$\bullet$] 8 bits d'exposant
    \item[$\bullet$] 23 bits de mantisse
\end{itemize}

b. Convertissons d'abord \texttt{0x414BD000} en binaire :
\begin{equation*}
    414BD000_{16} = 01000001010010111101000000000000_2
\end{equation*}
On identifie ensuite les bits de signe, d'exposant et de mantisse :
\begin{equation*}
    \underset{S}{\underbrace{0}}~\underset{E=130}{\underbrace{10000010}}~\underset{T}{\underbrace{10010111101000000000000}}
\end{equation*}
Le biais $b$ valant 127, notre exposant ici vaut $E-b = 3$. Donc, en "écriture binaire à virgule", on obtient :
\begin{equation*}
    1.10010111101 \times 2^3 = \underset{=12}{\underbrace{1100}}.\underset{=0.73828125}{\underbrace{10111101}}
\end{equation*}
Soit finalement :
\begin{center}
    \texttt{0x414BD000}$_{16}$ encode $12.73828125$
\end{center}

c. En suivant le raisonnement inverse, on peut trouver l'exposant et la mantisse de l'encodage de 0.1. On commence par l'écrire en "binaire à virgule" :
\begin{equation*}
    0.1 = 000110011001100110011001101_2
\end{equation*}
On décale la virgule pour trouver l'exposant :
\begin{equation*}
    0.1 = 1.10011001100110011001101_2 \times 2^{-4}
\end{equation*}
Cela donne donc un exposant de $E = b - 4 = 123 = 01111011_2$ sur 8 bits. Enfin, $0.1 > 0$ donc on met un premier bit à 0. On obtient donc l'encodage suivant -- dont on donne également la valeur décimale réelle -- pour le nombre 0.1 :
\begin{equation*}
    \underset{\text{signe}}{\underbrace{0}}\underset{\text{exposant}}{\underbrace{01111011}}\underset{\text{mantisse}}{\underbrace{10011001100110011001101_2}} = 0.100000001490116119384765625
\end{equation*}

\section{Chapitre 2}
\subsection{Exercice 1}
a. Lorsqu'on crée par exemple un tableau de taille un milliard, on obtient une erreur similaire à la suivante :
\begin{lstlisting}[style=CStyle]
[1]    54133 segmentation fault  ./a.out
\end{lstlisting}
b. En expérimentant à la main, on trouve qu'on peut créer un tableau de taille maximale 2 096 286.

\subsection{Exercice 2}
On vérifie par exemple qu'on peut créer un tableau de taille un milliard.

\subsection{Exercice 3}
La machine utilisée pour ce TD utilise la convention \textit{little endian}.

\subsection{Exercice 4}
On écrit déjà le code suivant :
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
#include <x86intrin.h>

unsigned long int squareSum(int n){
        unsigned long int tic,toc;
        unsigned int ui;
        int a = 0;
        tic = __rdtscp(&ui);
        for (int i=0; i < n; ++i){
            a = a*a+a*a;
        }
        toc = __rdtscp(&ui);
        return toc-tic;
    }

int main(){
    printf("n=%d: %lu tics\n", 1000, squareSum(1000));
    printf("n=%d: %lu tics\n", 10000, squareSum(10000));
    printf("n=%d: %lu tics\n", 1000000, squareSum(1000000));
    printf("n=%d: %lu tics\n", 10000000, squareSum(10000000));
    printf("n=%d: %lu tics\n", 100000000, squareSum(100000000));
    return 0;
}
\end{lstlisting}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c || c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^4$ & $10^6$ & $10^7$ & $10^8$ \\
        \hline
    mesure & 3310 & 42456 & 7134866 & 67719612 & 637584056\\ 
     \hline
    \end{tabular}
\end{center}
On note qu'on semble bien obtenir une relation qui a l'air linéaire, hormis la dernière mesure.

\subsection{Exercice 5}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        1er & 9108 & 835910 & 52244848 & 532734614 & 5350923602\\ 
        \hline
        2ème & 3238 & 685744 & 31633110 & 317468584 & 3161147144\\ 
        \hline
        3ème & 3088 & 322012 & 32683670 & 341747932 & 3100426690\\ 
        \hline
    $\frac{\text{écart max.}}{\text{moyenne}}$ en \% & 117 & 83 & 53 & 53 & 58\\ 
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. On teste la fonction avec la fonction \texttt{test} calculant la somme des premiers carrés. On obtient des résultats cohérents (croissance linéaire). La fonction \texttt{print\_timing} comprend une amorce qui exécute 10 fois la fonction à tester et moyenne les mesures sur 100 appels.

b. Voici la fonction \texttt{print\_timing}:

\begin{lstlisting}[style=CStyle]
void print_timing(int arg, void (*func)(int), int nb_boot, int nb_call)
{
    // boot up
    for (int i = 0; i < nb_boot; i++)
    {
        func(arg);
    }

    // measure
    unsigned long int tic, toc;
    unsigned int ui;
    tic = __rdtscp(&ui);
    for (int i = 0; i < nb_call; i++)
    {
        func(arg);
    }
    toc = __rdtscp(&ui);

    printf("average time : %lu\n", (toc - tic) / n);
}
\end{lstlisting}

c. Oui.

d. On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        mesure \texttt{print\_timing} & 4214 & 432308 & 31686176 & 308206789 & 3176004203\\ 
        \hline
    \end{tabular}
\end{center}

\subsection{Exercice 7}
On obtient les résultats suivants (arrondis):
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
        pas & $1$ & $2$ & $3$ & $4$ & $8$ & $16$ & $32$ \\
        \hline
        mesure ($\times 10^6$ tics)& 59 & 61 & 63 & 66 & 83 & 102 & 197 \\ 
        \hline
    \end{tabular}
\end{center}

On peut ainsi tracer les résultats obtenus pour les pas situés entre 1 et 1000:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=7cm,
            legend pos = south east,
            xlabel=step,
            ylabel=tics]
        \addplot[
            domain = 60:1000,
            samples = 20,
            smooth,
            thin,
            dashed,
            green!60!black,
        ] {600000000*(1-exp(-x/130))};
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex7.dat};
        \legend{
            Model,
            Measures, 
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
On remarque que les temps d'accès semblent converger\footnote{Plus précisément -- car on sait qu'il est impossible que cela converge -- on semble observer une croissance logarithmique.} ! Pour mieux l'illustrer, on trace par dessus les mesures la fonction suivante (en vert sur le graphique):
\begin{equation*}
    x \mapsto 6\times 10^8 (1-e^{-\frac{x}{130}})
\end{equation*}

\subsection{Exercice 8}

a. On écrit d'abord les deux fonctions suivantes\footnote{Il faut inclure les bibliothèques \texttt{stdlib} et \texttt{time} au début du code, et initialiser le \textit{seed} avec \texttt{srand(unsigned int)time(NULL)}.} :
\begin{lstlisting}[style=CStyle]
void access_seq(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[i];
    }
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
void access_rand(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[(unsigned long int)rand() % 1000000000];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 5111 & 5316032 & 44992606 & 450441905 & 4609590108\\ 
        \hline
        \texttt{access\_rand} & 3855618 & 139739559 & 1386369206 & 14181946914 & 148526968620 \\ 
        \hline
    \end{tabular}
\end{center}

b. On constate que la fonction \texttt{access\_rand} est (très largement, d'un facteur 30 environ) plus lente que la fonction \texttt{access\_seq} ! Est-ce réellement le cas ? Pour l'instant, on ne peut pas répondre à cette question, toutefois on peut facilement se rendre compte qu'on mesure bien trop de choses. En effet, à chaque accès aléatoire, on appelle -- donc on mesure -- la fonction \texttt{rand}, qui prend visiblement un temps non négligeable.


c. On modifie légèrement les fonctions de mesure\footnote{Tous les codes sont disponibles sur \href{https://github.com/VTrelat/ComputerArchitecture/tree/main/c}{GitHub}. Attention toutefois, l'exécution du code correspondant à cette mesure peut prendre plusieurs dizaines de minutes et nécessite au moins 32Go voire 64 Go de RAM.} et on écrit la fonction suivante :
\begin{lstlisting}[style=CStyle]
void access_aux(int *tab, unsigned long int *aux, unsigned long int n)
{
    int tmp;
    for (register unsigned long int i = 0; i < n; i++)
    {
        tmp = tab[aux[i]];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 4298 & 4263336 & 42850857 & 444757816 & 4356153500 \\
        \hline
        \texttt{access\_rand} & 3463 & 8848371 & 377748557 & 5385496993 & 97091291039 \\
        \hline
    \end{tabular}
\end{center}

On obtient les courbes suivantes:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=size,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex8_1.dat};
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch2/ex8_2.dat};
        \legend{
            Sequential, 
            Random,
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
Passons rapidement sur l'étude de ces courbes.\\
\textbf{Accès séquentiel}: on peut définir la fontion
\begin{equation*}
    t_{\text{seq}} \colon n \mapsto \tau_\text{seq} n
\end{equation*}
donnant une estimation temps mis pour réaliser des accès séquentiels en mémoire, où $\tau_\text{seq} \approx 4.298$. Le temps d'un accès séquentiel en mémoire, \textit{i.e.} sur des cases mémoires successives, est donc d'environ 4 \textit{tics}\footnote{Le temps de la mesure augmente linéairement avec le nombre d'accès mémoire. En moyennant, on obtient bien un temps constant par mesure.}. C'est très rapide !\\

\noindent
\textbf{Accès aléatoire}: on peut de même définir la fontion
\begin{equation*}
    t_{\text{rand}} \colon n \mapsto \tau_\text{rand} n
\end{equation*}
où $\tau_\text{rand} \approx 101.9$. Ainsi, un accès aléatoire dans la mémoire prendra environ 102 \textit{tics}. C'est approximativement 20 fois plus long que pour un accès séquentiel, toutefois cela reste du temps constant ! La différence s'explique par le fait que pour "sauter" d'une position à une autre, le pointeur qui fait office de tête de lecture doit faire un calcul arithmétique pour déterminer l'adresse mémoire de la case sur laquelle il doit se rendre. Cela peut nécessiter une soustraction, par exemple, ou encore un modulo, qui est tout de même assez coûteux (quelques dizaines de \textit{tics}).\\

\begin{framed}
    \textbf{Conclusion} :
    On constate ainsi que le temps mis pour faire un accès mémoire est constant, peu importe que l'accès soit séquentiel ou aléatoire. On comprend donc l'intérêt du modèle RAM (\textit{Random Acess Memory}) qui permet d'avoir cette propriété tout à fait indispensable aujourd'hui, puisqu'on fait en majorité des appels aléatoires.On peut donc accéder (quasi) instantanément à des données éparpillées en mémoire, ce qui se révèle notamment utile lorsqu'on sollicite plusieurs programmes en même temps.
\end{framed}

\end{document}