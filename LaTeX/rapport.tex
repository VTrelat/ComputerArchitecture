\documentclass[11pt, a4 paper]{article}
\usepackage[french]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multicol}
\usepackage{circuitikz}
\usepackage{pgfplots}
\usepackage{framed}
\usepackage{xcolor,colortbl}

%__________________________________________

% Node styles
\tikzstyle{white node}=[fill=none, draw=black, shape=circle, tikzit fill=white, tikzit draw=black]
\tikzstyle{red node}=[fill={rgb,255: red,232; green,118; blue,188}, draw=black, shape=circle, tikzit fill={rgb,255: red,232; green,118; blue,188}, tikzit draw=black]
\tikzstyle{blue node}=[fill={rgb,255: red,179; green,191; blue,255}, draw=black, shape=circle, tikzit fill={rgb,255: red,179; green,191; blue,255}, tikzit draw=black]
\tikzstyle{green node}=[fill={rgb,255: red,201; green,255; blue,189}, draw=black, shape=circle, tikzit fill={rgb,255: red,201; green,255; blue,189}, tikzit draw=black]

\tikzstyle{arrow}=[>]
\tikzstyle{new style 0}=[fill=none, draw=red, shape=circle, tikzit fill=none]
\tikzstyle{arrow}=[<--]
\tikzstyle{new edge style 2}=[- - -]

% Edge styles
\tikzstyle{right arrow}=[->]
\tikzstyle{right red arrow}=[->, draw=red, tikzit draw=red]
\tikzstyle{left arrow}=[<-]
\tikzstyle{left red arrow}=[<-, draw=red, tikzit draw=red]
\tikzstyle{right dashed arrow}=[->, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{left dashed arrow}=[<-, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{blue fill}=[-, fill={rgb,255: red,179; green,191; blue,255}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,207; blue,255}]
\tikzstyle{green fill}=[-, fill={rgb,255: red,201; green,255; blue,189}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,255; blue,208}]
\tikzstyle{red fill}=[-, fill={rgb,255: red,232; green,118; blue,188}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,232; green,118; blue,118}]

%__________________________________________

\usetikzlibrary{babel}
\usetikzlibrary{backgrounds}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}
\definecolor{lightgreen}{rgb}{0.94,1,0.94}
\definecolor{lightblue}{rgb}{0.94,0.94, 1}
\definecolor{lightred}{rgb}{1,0.94,0.94}
\definecolor{Cblue}{RGB}{40, 103, 237}
\definecolor{Corange}{RGB}{196, 108, 41}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.92,0.92,0.95}

\newcommand{\halmos}{\hfill$\blacksquare$}

\lstdefinestyle{customasm}{
    belowcaptionskip=1\baselineskip,
    frame=single, 
    frameround=tttt,
    xleftmargin=\parindent,
    language=[x86masm]Assembler,
    basicstyle=\footnotesize\ttfamily,
    commentstyle=\itshape\color{green!60!black},
    keywordstyle=\color{Cblue},
    identifierstyle=\color{Corange},
    tabsize=4,
    numbers=left,
    numbersep=8pt,
    stepnumber=1,
    numberstyle=\tiny\color{gray}, 
    columns = fullflexible,
}


\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{Cblue},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{Corange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,     
    frame=single,    
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}

\begin{document}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .2\textwidth]{img/logoartem.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Architecture des ordinateurs}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Erwan LEBAILLY | Vilavane LY | Vincent TRÉLAT | Benjamin ZHU
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\tableofcontents
\pagebreak

\section{Chapitre 1}
\subsection{Exercice 1}
Avec la convention $0 \leftrightarrow \texttt{faux}$ et $1 \leftrightarrow \texttt{vrai}$, $0 \wedge 1 = \texttt{faux}$.

\subsection{Exercice 2}
On donne la table de $c_0$ :
\begin{center}
    $c_0 \colon$
    \begin{tabular}{||c | c | c ||} 
     \hline
     $a_0 \backslash b_0$ & 0 & 1 \\ [0.5ex] 
     \hline\hline
     0 & 0 & 1  \\ 
     \hline
     1 & 1 & 0 \\
     \hline
    \end{tabular}
\end{center}
On peut interpréter cette table comme la table de vérité du "ou exclusif", le \textit{xor}. Ainsi, $c_0$ coincide avec $a_0 \oplus b_0 = (a_0 \vee b_0) \wedge (\neg (a_0 \wedge b_0))$.

\subsection{Exercice 3}
a. Montrons que l'opérateur xor $\oplus$ est associatif et commutatif :\\
Soient $a, b, c \in \{0, 1\}$.\\

\textbf{Associativité :} on donne ci-dessous la table de vérité de $(a \oplus b) \oplus c$ et $a \oplus (b \oplus c)$:
\begin{center}
    \begin{tabular}{||c | c | c | c | c | c ||} 
     \hline
     $a$ & $b$ & $c$ & $a \oplus b$ & $(a \oplus b) \oplus c$ & $a \oplus (b \oplus c)$ \\ [0.5ex] 
     \hline\hline
    %a   b   c  a+b  r1 r2
     0 & 0 & 0 & 0 & 0 & 0\\ 
     0 & 0 & 1 & 0 & 1 & 1\\ 
     1 & 0 & 0 & 1 & 0 & 0\\ 
     1 & 0 & 1 & 1 & 0 & 0\\ 
     0 & 1 & 0 & 1 & 1 & 1\\ 
     0 & 1 & 1 & 1 & 0 & 0\\ 
     1 & 1 & 0 & 0 & 0 & 0\\ 
     1 & 1 & 1 & 0 & 1 & 1\\ 
     \hline
    \end{tabular}
\end{center}

\textbf{Commutativité :} on donne ci-dessous la table de vérité de $a \oplus b$ et $b \oplus a$:
\begin{center}
    \begin{tabular}{||c | c | c | c ||} 
     \hline
     $a$ & $b$ & $a \oplus b$ & $b \oplus a$ \\ [0.5ex] 
     \hline\hline
    %a   b  a+b  b+a
    0 & 0 & 0 & 0 \\
    0 & 1 & 1 & 1 \\
    1 & 0 & 1 & 1 \\
    1 & 1 & 0 & 0 \\
     \hline
    \end{tabular}
\end{center}

Enfin, $a \oplus a = 0$ et $a \oplus 0 = a$.\\

On peut maintenant montrer le résultat demandé :\\
\begin{equation*}
    d = a \oplus c = a \oplus (a \oplus b) = a \oplus a \oplus b = b
\end{equation*}

\begin{equation*}
    e = b \oplus c = b \oplus (a \oplus b) = b \oplus a \oplus b = a
\end{equation*}

\halmos

b. On donne ci-dessous le circuit correspondant :
\begin{center}
    \begin{circuitikz}[framed, scale=1.5]
        % \draw (0,0) node[ american and port ] {};
        % \draw (0,2) node[ american or port ] {};
        % \draw (0,6) node[ american not port ] {};
    
        \draw (0,1) node (a) {a};
        \draw (7,1) node (d) {d};
        \draw (0,-1) node (b) {b};
        \draw (7,-1) node (e) {e};
        \draw (3,0) node[ american xor port ] (xor1) {};
        \draw (6,1) node[ american xor port ] (xor2) {};
        \draw (6,-1) node[ american xor port ] (xor3) {};
        
        \draw (.2, 1) -- (xor1.in 1);
        \draw (.2, 1) -| (xor2.in 1);
        \draw (xor1.out) |- (xor2.in 2);
        \draw (xor1.out) |- (xor3.in 1);
        \draw (.2, -1) -- (xor1.in 2);
        \draw (.2, -1) -| (xor3.in 2);
        
        \draw (xor2.out) -| (6.8,1);
        \draw (xor3.out) -| (6.8,-1);
        
    \end{circuitikz}
\end{center}

\subsection{Exercice 4}
a. On écrit le code suivant :\\
\begin{lstlisting}[style=CStyle]
int main()
    {
        printf("Sizeof int: %lu octets\n", sizeof(int));
        printf("Sizeof short: %lu octets\n", sizeof(short));
        printf("Sizeof char: %lu octets\n", sizeof(char));
        return 0;
    }
\end{lstlisting}

La sortie est la suivante :\\
\begin{lstlisting}[style=CStyle]
    Sizeof int: 4 octets
    Sizeof short: 2 octets
    Sizeof char: 1 octets
\end{lstlisting}

b. On écrit le code suivant :
\begin{lstlisting}[style=CStyle]
int main()
    {
        int a = pow(2, 31);
        int b = pow(2, 31);
        int c = a + b;
        printf("%d\n", c);
        return 0;
    }
\end{lstlisting}

La sortie affiche 0, ce qui correspond bien à $2^{32} \mod(2^{32})$

\subsection{Exercice 5}
On donne ci-dessous l'écriture binaire sur 4 et 8 bits de 0, 1, -1 et -2:
\begin{center}
    \begin{tabular}{c | c | c} 
    $x$ & 4 bits & 8 bits\\
        \hline
        \hline
    0 :& 0000 & 0000 0000\\ 
    1 :& 0001 & 0000 0001\\
    -1 :& 1111 & 1111 1111\\
    -2 :& 1110 & 1111 1110\\
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. $m_1 = 0001$ et $m_{-1} = 1001$.

b. En abusant de la notation + pour des mots : $m_0 = m_1 + m_{-1} = 1010$.

c. En suivant la règle de signes, 1010 est l'encodage de -2.

\subsection{Exercice 7}
Soit $b$ un nombre de bits. Soit $x$ un entier relatif qu'on souhaite représenter sur $b$ bits.\\
Si $x \geq 0$, alors l'encodage de $x$ correspond à une écriture dans $[0, 2^{b-1}-1]$, alors cette écriture commence par un zéro (de 00...0 à 01...1).
Si $x < 0$, alors $2^b - x \in [2^{b-1}, 2^b-1]$ (soit de 10...0 à 11...1), son écriture commence par un 1.

\halmos


\subsection{Exercice 8}
Dans le premier code, on dispose de 2 cases mémoires différentes.
Le résultat affiché est -106 pour la valeur de d, ce qui est normal puisque d est signé.\\
Dans le deuxième code, on utilise une seule case mémoire à travers l'utilisation de deux pointeurs, un signé et un non signé.
Le résultat affiché est identique au premier code.\\
Cela permet de montrer que la mémoire est "non typée", l'interprétation de la valeur mémoire dépend directement du type de l'objet qui lit cette valeur.

\subsection{Exercice 9}
a. 10 s'écrit $2\times5$ et toute puissance de 2 s'écrit $2^k$ où $k\in \mathbb{N}$.\\
Ainsi, si $x \in 2^{\mathbb{N}}$ (par abus de langage) est divisible par 10, alors $x$ contient au moins 2 et 5 dans sa décomposition en facteurs premiers, ce qui donne une contradition avec la propriété précédemment énoncée.\\

\halmos

b. Supposons que $0.1$ soit représentable sur $kl$ bits.
Alors, d'après le résultat du cours, $2^l \times 0.1$ est un entier, autrement dit $2^l$ est divisible par 10.
D'après la question précédente, c'est impossible.

\halmos

\subsection{Exercice 10}
L'écriture binaire approchée de $0.1$ est $0.0001~1001_2$, de valeur décimale $0.09765625$.

\subsection{Exercice 11}
a. On écrit la fonction suivante en C :

\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            printf("(%d, %d) : %s\n", i, j, (a+b == c)?"true":"false");
        }
    } 
    return 0;
}
\end{lstlisting}

La sortie affichée contient, entre autres, les résultats suivants :
\begin{multicols}{2}
    \begin{itemize}
        \item[$\bullet$] (1, 4) : true
        \item[$\bullet$] (1, 5) : true
        \item[$\bullet$] (1, 6) : false
        \item[$\bullet$] (1, 7) : true
        \item[$\bullet$] (1, 8) : false
        
        \item[$\bullet$] (3, 4) : false
        \item[$\bullet$] (3, 5) : true
        \item[$\bullet$] (3, 6) : false
        \item[$\bullet$] (3, 7) : true
        \item[$\bullet$] (3, 8) : true
    \end{itemize}    
\end{multicols}

b. On modifie seulement la ligne d'affichage dans le code\footnote{Comme un \texttt{int} est codé sur 4 octets, on donne 16 caractères à chaque affichage.} :
\begin{lstlisting}[style=CStyle]
printf("%.16f + %.16f = %.16f\n", a, b, c);
\end{lstlisting}
On donne seulement les résultats pour les 5 premiers couples ci-dessus :
\begin{lstlisting}[style=CStyle]
0.1000000014901161 + 0.4000000059604645 = 0.5000000000000000
0.1000000014901161 + 0.5000000000000000 = 0.6000000238418579
0.1000000014901161 + 0.6000000238418579 = 0.6999999880790710
0.1000000014901161 + 0.6999999880790710 = 0.8000000119209290
0.1000000014901161 + 0.8000000119209290 = 0.8999999761581421
\end{lstlisting}

c. On remarque que pour une addition, l'égalité \texttt{a+b==c} est vérifiée lorsque \texttt{a} et \texttt{b} sont représentables, ou quand l'un des deux seulement l'est.
Dans le second cas, l'erreur de représentation n'a pas eu d'impact sur le résultat puisque c'est la seule erreur du calcul.
Ainsi l'égalité reste vraie.\\
En revanche, dès que les deux flottants ne sont pas représentables, les erreurs s'accumulent et alors la représentation de \texttt{c} peut différer de la valeur de \texttt{a+b}.\\

Dans un cas général si on prend $x, y \in \mathbb{R}$ tels que $x=y$, on aura \texttt{x==y} quand $x$ et $y$ sont représentables sur un nombre de bits donné
    \footnote{
        Il faut tout de même faire attention à la précision.
        Augmenter la précision ne rendra pas les calculs exacts pour autant.
    }.
Dans les autres cas, il est possible d'obtenir un résultat correct mais cela résulte plutôt du hasard.\\

d. On modifie la fonction précédente :
\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            if(a+b!=c){
                int m1 = a+b>c;
                int m2 = a+b+.000001>c+.000001;
                printf("(%d, %d) : %d %d\n", i, j, m1, m2);
            }
        }
    } 
    return 0;
}
\end{lstlisting}

On obtient la sortie suivante :
\begin{lstlisting}[style=CStyle]
// a+b > c is tested before and after adding 1e-6
(1, 6) : 1 1
(1, 8) : 1 1
(3, 4) : 1 1
(3, 6) : 1 1
(4, 3) : 1 1
(6, 1) : 1 1
(6, 3) : 1 1
(6, 8) : 1 1
(7, 9) : 0 0
(8, 1) : 1 1
(8, 6) : 1 1
(9, 7) : 0 0
\end{lstlisting}
On constate que l'ordre est conservé à chaque fois.
Comme $10^{-6}$ n'est pas représentable sur 16 bits ($10^{-6} \approx 2^{-20}$), on simule l'effet de la propagation d'une erreur.\\
On en déduit que des erreurs successives d'arrondi ne bousculent pas l'ordre sur des valeurs arrondies.
Toutefois ici on effectue le même calcul des deux côtés.
On peut donc toujours les comparer\footnote{Pas l'égalité.}, même après plusieurs calculs, puisque l'ordre est conservé.
On peut également penser que cela ne provoquera pas d'évolution chaotique ou aléatoire de ces valeurs dans les calculs.
En revanche, pour une suite d'opérations inconnue, cela risque de devenir insignifiant de vouloir comparer deux flottants.

\subsection{Exercice 12}
On note $s_1 = \displaystyle{\sum_{i=1}^{k} \frac{1}{i}}$ et $s_2 = \displaystyle{\sum_{i=k}^{1} \frac{1}{i}}$.\\
On écrit la fonction suivante :

\begin{lstlisting}[style=CStyle]
int main() {
    float s1 = 0.0, s2 = 0.0;
    long k = 1000000000;
    for (double i = 1; i<k+1; i++){
        s1 += 1/i;
        s2 += 1/(k+1-i);
    }
    printf("k=%ld\n    s1 = %.16f\n    s2 = %.16f\n", k, s1, s2);
    return 0;
}
\end{lstlisting}

Les résultats sont les suivants :
\begin{lstlisting}[style=CStyle]
k=1000
    s1 = 7.4854784011840820
    s2 = 7.4854717254638672
k=1000000
    s1 = 14.3573579788208008
    s2 = 14.3926515579223633
k=1000000000
    s1 = 15.4036827087402344
    s2 = 18.8079185485839844
\end{lstlisting}
On constate que les résultats diffèrent\footnote{Même plus que ça, on dirait que la série converge !
On connait l'équivalent pour la série harmonique : $H_n \underset{n \to +\infty}{\sim} \gamma + \ln(n)$ où $\gamma \approx 0.5$ est la constante d'Euler.
Pour $n = 10^9$, on devrait donc plutôt être autour de $H_n \approx 21$.} d'autant plus que le nombre d'erreurs successives est grand, ce qui n'est pas étonnant.
Là où le résultat interpelle, c'est que l'ordre de parcours de la somme a un impact conséquent sur le résultat.\\
Cette erreur est due au fait que lorsque le parcours est décroissant, on finit pas les petits nombres.
Ces derniers causent alors des erreurs d'arrondi car leur ordre de grandeur est faible par rapport aux premiers nombres.

\subsection{Exercice 13}
a. La taille d'un \texttt{float} en C est de 4 \textit{bytes}, soit 32 bits :
\begin{itemize}
    \item[$\bullet$] 1 bit de signe
    \item[$\bullet$] 8 bits d'exposant
    \item[$\bullet$] 23 bits de mantisse
\end{itemize}

b. Convertissons d'abord \texttt{0x414BD000} en binaire :
\begin{equation*}
    414BD000_{16} = 01000001010010111101000000000000_2
\end{equation*}
On identifie ensuite les bits de signe, d'exposant et de mantisse :
\begin{equation*}
    \underset{S}{\underbrace{0}}~\underset{E=130}{\underbrace{10000010}}~\underset{T}{\underbrace{10010111101000000000000}}
\end{equation*}
Le biais $b$ valant 127, notre exposant ici vaut $E-b = 3$. Donc, en "écriture binaire à virgule", on obtient :
\begin{equation*}
    1.10010111101 \times 2^3 = \underset{=12}{\underbrace{1100}}.\underset{=0.73828125}{\underbrace{10111101}}
\end{equation*}
Soit finalement :
\begin{center}
    \texttt{0x414BD000}$_{16}$ encode $12.73828125$
\end{center}

c. En suivant le raisonnement inverse, on peut trouver l'exposant et la mantisse de l'encodage de 0.1. On commence par l'écrire en "binaire à virgule" :
\begin{equation*}
    0.1 = 000110011001100110011001101_2
\end{equation*}
On décale la virgule pour trouver l'exposant :
\begin{equation*}
    0.1 = 1.10011001100110011001101_2 \times 2^{-4}
\end{equation*}
Cela donne donc un exposant de $E = b - 4 = 123 = 01111011_2$ sur 8 bits.
Enfin, $0.1 > 0$ donc on met un premier bit à 0. On obtient donc l'encodage suivant -- dont on donne également la valeur décimale réelle -- pour le nombre 0.1 :
\begin{equation*}
    \underset{\text{signe}}{\underbrace{0}}\underset{\text{exposant}}{\underbrace{01111011}}\underset{\text{mantisse}}{\underbrace{10011001100110011001101_2}} = 0.100000001490116119384765625
\end{equation*}

\pagebreak

\section{Chapitre 2}
\subsection{Exercice 1}
a. Lorsqu'on crée par exemple un tableau de taille un milliard, on obtient une erreur similaire à la suivante :
\begin{lstlisting}[style=CStyle]
[1]    54133 segmentation fault  ./a.out
\end{lstlisting}
b. En expérimentant à la main, on trouve qu'on peut créer un tableau de taille maximale 2 096 286.

\subsection{Exercice 2}
On vérifie par exemple qu'on peut créer un tableau de taille un milliard.

\subsection{Exercice 3}
La machine utilisée pour ce TD utilise la convention \textit{little endian}.

\subsection{Exercice 4}
On écrit déjà le code suivant :
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
#include <x86intrin.h>

unsigned long int squareSum(int n){
    unsigned long int tic, toc;
    unsigned int ui;
    int a = 0;
    tic = __rdtscp(&ui);
    for (int i = 0; i < n; ++i){
        a = i * i;
    }
    toc = __rdtscp(&ui);
    return toc - tic;
}
int main(){
    printf("n=%d: %lu tics\n", 1000, squareSum(1000));
    printf("n=%d: %lu tics\n", 10000, squareSum(10000));
    printf("n=%d: %lu tics\n", 1000000, squareSum(1000000));
    printf("n=%d: %lu tics\n", 10000000, squareSum(10000000));
    printf("n=%d: %lu tics\n", 100000000, squareSum(100000000));
    return 0;
}
\end{lstlisting}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c || c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^4$ & $10^6$ & $10^7$ & $10^8$ \\
        \hline
    mesure & 3310 & 42456 & 7134866 & 67719612 & 637584056\\ 
     \hline
    \end{tabular}
\end{center}
On note qu'on semble bien obtenir une relation qui a l'air linéaire, hormis la dernière mesure.

\subsection{Exercice 5}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        1er & 9108 & 835910 & 52244848 & 532734614 & 5350923602\\ 
        \hline
        2ème & 3238 & 685744 & 31633110 & 317468584 & 3161147144\\ 
        \hline
        3ème & 3088 & 322012 & 32683670 & 341747932 & 3100426690\\ 
        \hline
    $\frac{\text{écart max.}}{\text{moyenne}}$ en \% & 117 & 83 & 53 & 53 & 58\\ 
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. On teste la fonction avec la fonction \texttt{test} calculant la somme des premiers carrés. On obtient des résultats cohérents (croissance linéaire).
La fonction \texttt{print\_timing} comprend une amorce qui exécute 10 fois la fonction à tester et moyenne les mesures sur 100 appels.

b. Voici la fonction \texttt{print\_timing}:

\begin{lstlisting}[style=CStyle]
void print_timing(int arg, void (*func)(int), int nb_boot, int nb_call)
{
    // boot up
    for (int i = 0; i < nb_boot; i++)
    {
        func(arg);
    }

    // measure
    unsigned long int tic, toc;
    unsigned int ui;
    tic = __rdtscp(&ui);
    for (int i = 0; i < nb_call; i++)
    {
        func(arg);
    }
    toc = __rdtscp(&ui);

    printf("average time : %lu\n", (toc - tic) / n);
}
\end{lstlisting}

c. Oui.

d. On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        mesure \texttt{print\_timing} & 4214 & 432308 & 31686176 & 308206789 & 3176004203\\ 
        \hline
    \end{tabular}
\end{center}

\subsection{Exercice 7}
On obtient les résultats suivants (arrondis):
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
        pas & $1$ & $2$ & $3$ & $4$ & $8$ & $16$ & $32$ \\
        \hline
        mesure ($\times 10^6$ tics)& 59 & 61 & 63 & 66 & 83 & 102 & 197 \\ 
        \hline
    \end{tabular}
\end{center}

On peut ainsi tracer les résultats obtenus pour les pas situés entre 1 et 1000:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=7cm,
            legend pos = south east,
            xlabel=step,
            ylabel=tics]
        \addplot[
            domain = 60:1000,
            samples = 20,
            smooth,
            thin,
            dashed,
            green!60!black,
        ] {600000000*(1-exp(-x/130))};
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex7.dat};
        \legend{
            Model,
            Measures, 
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
On remarque que les temps d'accès semblent converger\footnote{Plus précisément -- car on sait qu'il est impossible que cela converge -- on semble observer une croissance logarithmique.}!
Pour mieux l'illustrer, on trace par dessus les mesures la fonction suivante (en vert sur le graphique):
\begin{equation*}
    x \mapsto 6\times 10^8 (1-e^{-\frac{x}{130}})
\end{equation*}

% On mesure des temps d'accès dont la proportion d'accès hors-cache augmente

\subsection{Exercice 8}

a. On écrit d'abord les deux fonctions suivantes\footnote{Il faut inclure les bibliothèques \texttt{stdlib} et \texttt{time} au début du code, et initialiser le \textit{seed} avec \texttt{srand(unsigned int)time(NULL)}.} :
\begin{lstlisting}[style=CStyle]
void access_seq(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[i];
    }
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
void access_rand(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[(unsigned long int)rand() % 1000000000];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 5111 & 5316032 & 44992606 & 450441905 & 4609590108\\ 
        \hline
        \texttt{access\_rand} & 3855618 & 139739559 & 1386369206 & 14181946914 & 148526968620 \\ 
        \hline
    \end{tabular}
\end{center}

b. On constate que la fonction \texttt{access\_rand} est (très largement, d'un facteur 30 environ) plus lente que la fonction \texttt{access\_seq}!
Est-ce réellement le cas ? Pour l'instant, on ne peut pas répondre à cette question, toutefois on peut facilement se rendre compte qu'on mesure bien trop de choses.
En effet, à chaque accès aléatoire, on appelle -- donc on mesure -- la fonction \texttt{rand}, qui prend visiblement un temps non négligeable.


c. On modifie légèrement les fonctions de mesure\footnote{Tous les codes sont disponibles sur \href{https://github.com/VTrelat/ComputerArchitecture/tree/main/c}{GitHub}.
Attention toutefois, l'exécution du code correspondant à cette mesure peut prendre plusieurs dizaines de minutes et nécessite au moins une dizaine de Go de RAM.} et on écrit la fonction suivante :
\begin{lstlisting}[style=CStyle]
void access_aux(int *tab, unsigned long int *aux, unsigned long int n)
{
    int tmp;
    for (register unsigned long int i = 0; i < n; i++)
    {
        tmp = tab[aux[i]];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 4298 & 4263336 & 42850857 & 444757816 & 4356153500 \\
        \hline
        \texttt{access\_rand} & 3463 & 8848371 & 377748557 & 5385496993 & 97091291039 \\
        \hline
    \end{tabular}
\end{center}

On obtient les courbes suivantes:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5.5cm,
            legend pos = north west,
            xlabel=size,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex8_1.dat};
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch2/ex8_2.dat};
        \legend{
            Sequential, 
            Random,
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
Passons rapidement sur l'étude de ces courbes.\\
\textbf{Accès séquentiel}: on peut définir la fontion
\begin{equation*}
    t_{\text{seq}} \colon n \mapsto \tau_\text{seq} n
\end{equation*}
donnant une estimation temps mis pour réaliser des accès séquentiels en mémoire, où $\tau_\text{seq} \approx 4.298$.
Le temps d'un accès séquentiel en mémoire, \textit{i.e.} sur des cases mémoires successives, est donc d'environ 4 \textit{tics}\footnote{Le temps de la mesure augmente linéairement avec le nombre d'accès mémoire.
En moyennant, on obtient bien un temps constant par mesure.}. C'est très rapide !\\

\noindent
\textbf{Accès aléatoire}: on peut de même définir la fontion
\begin{equation*}
    t_{\text{rand}} \colon n \mapsto \tau_\text{rand} n
\end{equation*}
où $\tau_\text{rand} \approx 101.9$. Ainsi, un accès aléatoire dans la mémoire prendra environ 102 \textit{tics}.
C'est approximativement 20 fois plus long que pour un accès séquentiel, toutefois cela reste du temps constant !
La différence peut déjà s'expliquer par le fait que pour "sauter" d'une position à une autre, le pointeur qui fait office de tête de lecture doit faire un calcul arithmétique pour déterminer l'adresse mémoire de la case sur laquelle il doit se rendre.
Cela peut nécessiter une soustraction, par exemple, ou encore un modulo, qui est tout de même assez coûteux (quelques dizaines de \textit{tics}).

\begin{framed}
    \textbf{Conclusion} :
    Néanmoins, la vraie différence vient d'un autre phénomène qui est la mise en cache de données\footnote{cf Chapitre 3}.
    Lorsqu'on fait des accès séquentiel, on charge des blocs en cache, et on fait une suite d'accès en cache, ce qui est rapide.
    Lorsqu'on fait une suite d'accès aléatoires, on fait des accès hors-cache presque à chaque nouvel accès, puisque la probabilité que deux accès consécutifs concernent des données présentes dans un même bloc est beaucoup plus faible.
\end{framed}

\pagebreak

\section{Chapitre 3}
\subsection{Exercice 1}
\noindent
\texttt{0xAE01D500} et \texttt{0xAE01D501} \hfill Oui \hfill \\
\texttt{0xAE01D500} et \texttt{0xAE01D4FF} \hfill Non \hfill \\
\texttt{0xAE01D500} et \texttt{0xAE01D580} \hfill Non \hfill \\
\texttt{0xAE01D53D} et \texttt{0xAE01D542} \hfill Oui \hfill \\
\texttt{0xAD01F506} et \texttt{0xAE01D508} \hfill Non \hfill \\
\texttt{0xAE01D55F} et \texttt{0xAE01D560} \hfill Oui \hfill \\

\subsection{Exercice 2}
On vérifie déjà qu'une instance de type \texttt{noeud} occupe bien 24 octets avec la commande:\\
\begin{lstlisting}[style=CStyle]
printf("sizeof noeud: %lu o", sizeof(struct noeud));
\end{lstlisting}
Le fait que la somme des tailles diffère de la taille de la somme (de la structure) provient de la compilation : le compilateur fait de l'alignment (\textit{padding}) sur des multiples de 8 afin qu'un élément se trouve toujours en début de bloc.
Ainsi, un \texttt{noeud} occupe une taille de $20+4=24$ octets.\\

a. On peut stocker $\frac{32\times1024}{64} = 512$ blocs.
Le noeud 14 par exemple commence à l'adresse \texttt{0xAE01D53C} et finit à l'adresse \texttt{0xAE01D54F}.
Or, le premier bloc se termine à l'adresse \texttt{0xAE01D540}\footnote{\texttt{0xAE01D500} décalé de 64 octets}, soit au "milieu" du noeud 14.\\

b. On commence par lire le noeud 1, qui charge -- c'est donc un accès hors-cache -- le bloc contenant la fin du noeud 20, le 1, le 25 et le début du noeud 22.
Ensuite, on lit le noeud 2 qui charge le bloc -- accès hors-cache -- qui contient les noeuds 2, 9 et le début du noeud 14.
On fait de même pour le noeud 3, puis pour le 4, on doit charger deux blocs car le noeud 4 est à cheval sur ces deux blocs : on charge donc les noeuds 27 (fin), 10, 24, 4, 21 et 13.
On continue jusqu'au noeud 8, qui est dans le bloc du noeud 7, donc pas d'accès hors-cache.\\
Pour résumer, sur les 27 accès, les accès hors-cache sont : 1, 2, 3, 4, 5, 6, 7 et 16.

\subsection{Exercice 3}

On obtient les résultats suivants\footnote{Sous Mac, on peut accéder à ce genre d'informations par la commande \texttt{sysctl}.
En particulier, ici on peut utiliser la commande \texttt{sysctl -a | grep hw}.}:
\begin{center}\label{ex3:tab}
    \begin{tabular}{| c || c | c | c | c |}
        \hline
    & L1 instruction & L1 données & L2 & L3 \\
        \hline
    Taille mémoire & 32768 & 32768 & 262144 & 16777216 \\
        \hline
    Ligne de cache & 64 & 64 & 64 & 64 \\
        \hline
    Associativité & 8 & 8 & 4 & 16 \\
        \hline
    \end{tabular}
\end{center}

\subsection{Exercice 4}
On cherche à mettre en évidence la taille du cache L1 et du cache L2.
Pour cela, on va regarder les temps mis pour parcourir un tableau en colonnes et si on observe un pic pour une taille $N$ de tableau, cela signifie que le cache est de taille $64\times N$ ko.
En l'occurrence, on s'attend à voir un pic autour de $N = \frac{32768}{64} = 512$ pour L1 et $N = \frac{262144}{64} = 4096$ pour L2.

\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5cm,
            legend pos = north west,
            xlabel=$N$,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex4a};
        \node at (axis cs:480,3100)(B){$N=512$};
        \node at (axis cs:512,3187)(C){};
        \draw [->](B.east)--(C.west);
        \end{axis}
    \end{tikzpicture}
    \caption{Mise en évidence du cache L1}
\end{figure}

\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5cm,
            legend pos = north west,
            xlabel=$N$,
            ylabel=tics]
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch3/ex4b};
        \node at (axis cs:4085,115000)(B){$N=4096$};
        \node at (axis cs:4096,125000)(C){};
        \draw [->](B.east)--(C.west);
        \end{axis}
    \end{tikzpicture}
    \caption{Mise en évidence du cache L2}
\end{figure}

On donne quelques valeurs numériques autour de $N = 4096$ ci-dessous:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
    n & 4094 & 4095 & 4096 & 4097 & 4098 & 4099 \\
    \hline
    en ligne & 59737 & 54042 & 52042 & 56912 & 61912 & 62952 \\
    \hline
    en colonne & 61302 & 63239 & 126933 & 97693 & 78726 & 67656 \\
    \hline
    \end{tabular}
\end{center}

\subsection{Exercice 5}
Voir le tableau de l'\nameref{ex3:tab}\footnote{Note : sous Mac, on obtient seulement la valeur de l'associativité pour le cache L2 : \texttt{machdep.cpu.cache.L2\_associativity: 4
}.
Toutes les autres valeurs ont été obtenues sur la fiche technique du processeur fournie par Intel, en l'occurrence un \texttt{Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz}.}.\\


\subsection{Exercice 6}
% blocs : [2, 9, 19, 14], [14, 6, 15, 26], [26, 23, 16, ...]
On redonne ci-dessous les blocs de l'exercice 2 :\\
\begin{center}
    \begin{tabular}{| c | c || c | c || c | c |}
        \rowcolor{lightgrey}
        \hline
        $p$ & addresse & $p$ & addresse & $p$ & addresse \\
        \hline
        \hline
        \rowcolor{lightgreen}
        2 & \texttt{0xAE01D500} & 3 & \texttt{0xAF01D900} & 11 & \texttt{0xBF01DD00} \\
        \hline
        \rowcolor{lightgreen}
        9 & \texttt{0xAE01D514} & 17 & \texttt{0xAF01D914} & 5 & \texttt{0xBF01DD14} \\
        \hline
        \rowcolor{lightgreen}
        19 & \texttt{0xAE01D528} & 12 & \texttt{0xAF01D928} & 18 & \texttt{0xBF01DD28} \\
        \hline
        \rowcolor{lightgreen}
        14 & \texttt{0xAE01D53C} & 20 & \texttt{0xAF01D93C} & 27 & \texttt{0xBF01DD3C} \\
        \hline
        \hline
        \rowcolor{lightblue}
        14 & \texttt{0xAE01D53C} & 20 & \texttt{0xAF01D93C} & 27 & \texttt{0xBF01DD3C} \\
        \hline
        \rowcolor{lightblue}
        6 & \texttt{0xAE01D550} & 1 & \texttt{0xAF01D950} & 10 & \texttt{0xBF01DD50} \\
        \hline
        \rowcolor{lightblue}
        15 & \texttt{0xAE01D564} & 25 & \texttt{0xAF01D964} & 24 & \texttt{0xBF01DD64}\\
        \hline
        \rowcolor{lightblue}
        26 & \texttt{0xAE01D578} & 22 & \texttt{0xAF01D978} & 4 & \texttt{0xBF01DD78}\\
        \hline
        \hline
        \rowcolor{lightred}
        26 & \texttt{0xAE01D578} & 22 & \texttt{0xAF01D978} & 4 & \texttt{0xBF01DD78}\\
        \hline
        \rowcolor{lightred}
        23 & \texttt{0xAE01D58C} & 8 & \texttt{0xAF01D98C} & 21 & \texttt{0xBF01DD8C}\\
        \hline
        \rowcolor{lightred}
        16 & \texttt{0xAE01D5A0} & 7 & \texttt{0xAF01D9A0} & 13 & \texttt{0xBF01DDA0}\\
        \hline
    \end{tabular}
\end{center}
Si on dispose d'un cache de 1 Ko et d'un niveau d'associativité 2, on a $\frac{1024}{64} = 16$ blocs, 128 octets par sous-cache, soit 2 blocs et $\frac{1024}{128} = 8$ sous-caches.\\
Les couleurs dans le tableau représentent les blocs qui sont dans le même sous-cache.
Par exemple, pour 2, 3, 11, 9, 17, 5, etc:
\begin{itemize}
    \item[$\bullet$] \texttt{(0xAE01D500 >> 6) mod 8 = 4}
    \item[$\bullet$] \texttt{(0xAF01D900 >> 6) mod 8 = 4}
    \item[$\bullet$] \texttt{(0xAE01D500 >> 6) mod 8 = 4}
    \item[$\bullet$] \dots\\
\end{itemize}
% Sous caches :
% 1 : [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27], [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27], [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27]
% 2 : [20, 1, 25, 22], [27, 10, 24, 4], [14, 6, 15, 26], [20, 1, 25, 22]
% 3 : [22, 8, 7], [4, 21, 13], [26, 23, 16], [22, 8, 7]

Le premier appel qui est fait en cache est l'accès de 8, qui est dans le bloc chargé par 7.
Le premier appel hors-cache non trivial est l'accès à 9, qui est bien dans le même bloc que 2, mais les accès à 3 et à 5 ont écrasé le premier bloc entre temps.\\
En résumé :
\begin{itemize}
    \item[$\bullet$] \textit{cache-miss} : 1, 2, 3, 4, 5, 6, 7, 9, 12, 13, 16, 18, 19, 20, 22, 25, 27
    \item[$\bullet$] \textit{cache-hit} : 8, 10, 11, 14, 15, 17, 21, 23, 24, 26
\end{itemize}


% Ex 6 : cache 32 ko = 32 * 2**10
% 64 o * 2 = 128 o par sous-cache
% 32*2^10 / 2^7 = 256 sous-cache

% 2 octets séparés d'un multiple de 32768 en mémoire seront dans le même sous-cache

% cf ex2 : le bloc contenant 1 et le bloc contenant 11 sont dans le même sous-cache
%         3 et 27
%         20
%         26 et 21
%         22

% Corriger le sujet : si on a 1 ko de cache -> contient 1024 / 64 = 16 blocs et 1024/128 = 8 sous-caches
%             2, 3, 11 sont dans le même sous-cache
%             14, 20, 27
%             26, 22, 4
% /!\ 9 fait un cache-miss car on a chargé 3 et 5 entre temps.

\subsection{Exercice 7}
On trace les temps successifs obtenus pour les trois expériences (N valant 1000000, 1048576 puis 1300000):
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7a};
        \node at (axis cs:500,550)(B){$N=$1 000 000};
        \end{axis}
    \end{tikzpicture}
\end{figure}
\vspace{-20pt}
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7b};
        \node at (axis cs:500,550)(B){$N=$1 048 576};
        \end{axis}
    \end{tikzpicture}
\end{figure}
\vspace{-20pt}
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7c};
        \node at (axis cs:500,550)(B){$N=$1 300 000};
        \end{axis}
    \end{tikzpicture}
\end{figure}

On constate que pour $N=2^{20}$, les temps sont globalement toujours supérieurs aux deux autres cas. En effet, on peut calculer les temps moyens (\textit{i.e.} le temps total cumulé divisé par le nombre d'accès R) $T(N)$ dans chaque cas :
\begin{align*}
    T(1000000) = 227.726\\
    T(1048576) = 252.717\\
    T(1300000) = 239.417
\end{align*}

Pourquoi une recherche dichotomique dans un tableau de taille $2^{20}$ met un temps environ 10\% plus long qu'un tableau de taille 1 300 000 ?\\
Ce phénomène est lié au principe d'associativité dans le système de cache de l'architecture de la machine.
En effet, pour un tableau dont la taille est une puissance de 2, la taille de chaque sous-tableau est encore une puissance de 2.
Or, le nombre de sous-caches ici est aussi une puissance de 2 -- mais beaucoup plus petite\footnote{En l'occurrence pour le cache L1 cette puissance est 3 et pour L2 elle vaut 2 !}, d'où le $2^{20}$ -- donc à chaque accès au milieu du tableau tombe sur une puissance de 2.
Or, on sait que les blocs mis en cache sont mis dans le sous-cache dont le numéro est calculé "modulo le nombre de sous-cache".
Ainsi, on écrase à chaque étape la valeur précédemment mise en cache.
On ne fait donc (presque) que des accès hors-cache, d'où le temps plus long.

\subsection{Exercice 8}
b. On écrit la fonction \texttt{transpose\_naive} suivante:
\begin{lstlisting}[style=CStyle]
void transpose_naive(int n, int *mat)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < i; j++)
        {
            int tmp = mat[i * n + j];
            mat[i * n + j] = mat[j * n + i];
            mat[j * n + i] = tmp;
        }
    }
}
\end{lstlisting}

On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    n & 1024 & 4096 & 8192 & 16384 & 65536 \\
    \hline
    temps & 7244426 & 373965628 & 1895640055 & 9090680074 & 171798691840\\
    \hline
    \end{tabular}
\end{center}

c. On écrit ensuite une fonction \texttt{transpose\_blocs} qui transpose une matrice en 4 blocs égaux:
\begin{lstlisting}[style=CStyle]
void transpose_blocs(int n, int *mat)
{
    for (int I = 0; I < n; I += n / 2)
    {
        for (int J = 0; J < n; J += n / 2)
        {
            int i_upper = min(I + n / 2, n);
            int j_upper = min(J + n / 2, n);
            for (int i = I; i < i_upper; i++)
            {
                for (int j = J; j < j_upper; j++)
                {
                    int tmp = mat[i * n + j];
                    mat[i * n + j] = mat[j * n + i];
                    mat[j * n + i] = tmp;
                }
            }
        }
    }
}
\end{lstlisting}

On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    n & 1024 & 4096 & 8192 & 16384 & 65536 \\
    \hline
    temps & 14578497 & 643229848 & 3429862750 & 17595195907 & 457658083617\\
    \hline
    \end{tabular}
\end{center}

d. Enfin, on définit la fonction \texttt{\_transpose\_rec} comme suit :
\begin{lstlisting}[style=CStyle]
void _transpose_rec(int *A, int mAb, int mAe, int nAb, int nAe, int m, int n, int S)
{
    int nblines = mAe - mAb;
    int nbcols = nAe - nAb;

    if ((nblines <= S) && (nbcols <= S))
    {
        int iA, jA;
        for (iA = mAb; iA < mAe; ++iA)
        {
            for (jA = nAb; jA < nAe; ++jA)
            {
                A[jA * m + iA] = A[iA * n + jA];
            }
        }
    }

    else if (nblines > nbcols)
    {
        int mid = nblines / 2;
        _transpose_rec(A, mAb + mid, mAe, nAb, nAe, m, n, S);
        _transpose_rec(A, mAb, mAb + mid, nAb, nAe, m, n, S);
    }
    else
    {
        int mid = nbcols / 2;
        _transpose_rec(A, mAb, mAe, nAb + mid, nAe, m, n, S);
        _transpose_rec(A, mAb, mAb, nAb, nAb + mid, m, n, S);
    }
}
\end{lstlisting}
Et on l'appellera sur \texttt{\_transpose\_rec(mat, 0, n, 0, n, n, n, 4)}\footnote{Le dernier argument S, qui vaut 4 ici, est une valeur de seuil sous laquelle on ne procède plus récursivement mais itérativement comme dans la fonction \texttt{transpose\_naive}.}.\\
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    n & 1024 & 4096 & 8192 & 16384 & 65536 \\
    \hline
    temps & 72610 & 627212 & 1604796 & 3357688 & 17023348\\
    \hline
    \end{tabular}
\end{center}
On regroupe toutes ces valeurs dans une seule figure:
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=10cm,
            legend pos = north west,
            xlabel=$n$,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex8a};
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch3/ex8b};
        \addplot[
            semithick,
            mGreen,
        ] file[skip first] {../c/ch3/ex8c};
        \legend{
            \texttt{transpose\_naive},
            \texttt{transpose\_blocs},
            \texttt{transpose\_rec},
        }
        \end{axis}
    \end{tikzpicture}
\end{figure}
\pagebreak

\section{Chapitre 4}
\subsection{Exercice 1}
On obtient le code assembleur suivant (avec \texttt{gcc}):
\begin{lstlisting}[style=customasm]
_sum:                                   ## @sum
## %bb.0:
	push	rbp
	mov	rbp, rsp
	mov	dword ptr [rbp - 4], edi
	mov	dword ptr [rbp - 8], 0
	mov	dword ptr [rbp - 12], 0
LBB0_1:                                 ## =>This Inner Loop Header: Depth=1
	mov	eax, dword ptr [rbp - 12]
	cmp	eax, dword ptr [rbp - 4]
	jge	LBB0_4
## %bb.2:                               ##   in Loop: Header=BB0_1 Depth=1
	mov	eax, dword ptr [rbp - 12]
	add	eax, dword ptr [rbp - 8]
	mov	dword ptr [rbp - 8], eax
## %bb.3:                               ##   in Loop: Header=BB0_1 Depth=1
	mov	eax, dword ptr [rbp - 12]
	add	eax, 1
	mov	dword ptr [rbp - 12], eax
	jmp	LBB0_1
LBB0_4:
	mov	eax, dword ptr [rbp - 8]
	pop	rbp
	ret
                                        ## -- End function
	.globl	_main                           ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
## %bb.0:
	push	rbp
	mov	rbp, rsp
	sub	rsp, 16
	mov	dword ptr [rbp - 4], 100000000
	mov	edi, dword ptr [rbp - 4]
	call	_sum
	xor	eax, eax
	add	rsp, 16
	pop	rbp
	ret
                                        ## -- End function
\end{lstlisting}

\subsection{Exercice 2}
Dans la fonction \texttt{sum}, on commence par sauvegarder la dernière valeur du pointeur \texttt{rbp} et empile cette valeur. Puis, tout est stocké dans la RAM : \texttt{edi} représente l'argument de la fonction (de manière informelle, c'est \texttt{count}), puis on stocke les valeurs de \texttt{s} et \texttt{i}, qui valent 0, au adresses qui suivent.
Pour le reste, on travaille sur des registres.


\subsection{Exercice 3}
a. Les trois instructions \texttt{mov}, \texttt{cmp} et \texttt{jge} correspondent aux instructions \texttt{for(int i=0; i<count; i++)} (la plupart du temps, \texttt{eax} représente la valeur de \texttt{i}, sauf à la toute fin où \texttt{eax} prend la valeur de \texttt{s}).\\
L'initialisation (\texttt{int i = 0}) est l'instruction \texttt{mov	eax, dword ptr [rbp - 12]}.
En particulier, le saut conditionnel ne se produit que si l'instruction \texttt{cmp	eax, dword ptr [rbp - 4]} est vérifiée, \textit{i.e.} lorsque \texttt{eax $\geq$ dword ptr [rbp - 4]}. Autrement dit, on sort de la boucle dès que \texttt{i} $\geq$ \texttt{count}.\\
Enfin, l'incrémentation se produit avec l'instruction \texttt{add	eax, 1}.\\

b. L'appel à la fonction \texttt{sum} se fait avec l'instruction \texttt{call	\_sum
}.\\

c. L'instruction \texttt{call} va chercher l'argument de la fonction dans le registre \texttt{edi}.\\

d. L'instruction \texttt{ret} va chercher la valeur de retour dans le registre \texttt{eax}.

\subsection{Exercice 4}
Premier code : \texttt{rax} vaut 47 à la fin et est équivalent au code C suivant:
\begin{lstlisting}[style=CStyle]
int i = 12;
i = i + i;
i = i + i;
i--;
\end{lstlisting}
Deuxième code : \texttt{rax} vaut 123 à la fin et est équivalent au code suivant:
\begin{lstlisting}[style=CStyle]
int a = 12;
for(int i = 0; i<10; i++){
    int a += 10;
}
\end{lstlisting}
Troisième code : \texttt{rax} vaut 143 à la fin et est équivalent au code suivant:
\begin{lstlisting}[style=CStyle]
int a = 12;
int b;
for(b=13; b>0; b--){
    a += 10;
}
\end{lstlisting}

\subsection{Exercice 5}
Premier code : \texttt{rax} vaut 15 au niveau de \texttt{nop}.
Deuxième code : \texttt{rax} vaut 12.
Troisième code : \texttt{rax} vaut \texttt{rbx}.

\subsection{Exercice 6}
a. On obtient le code assembleur suivante (avec \texttt{objdump}):
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
0000000000000000 <_main>:
    0: 55                           	push	rbp
    1: 48 89 e5                     	mov	rbp, rsp
    4: c7 45 fc 00 00 00 00         	mov	dword ptr [rbp - 4], 0
    b: c7 45 f4 00 00 00 00         	mov	dword ptr [rbp - 12], 0
   12: c7 45 f0 00 00 00 00         	mov	dword ptr [rbp - 16], 0
   19: 83 7d f0 64                  	cmp	dword ptr [rbp - 16], 100
   1d: 0f 8d 17 00 00 00            	jge	0x3a <_main+0x3a>
   23: 8b 45 f0                     	mov	eax, dword ptr [rbp - 16]
   26: 03 45 f4                     	add	eax, dword ptr [rbp - 12]
   29: 89 45 f4                     	mov	dword ptr [rbp - 12], eax
   2c: 8b 45 f0                     	mov	eax, dword ptr [rbp - 16]
   2f: 83 c0 01                     	add	eax, 1
   32: 89 45 f0                     	mov	dword ptr [rbp - 16], eax
   35: e9 df ff ff ff               	jmp	0x19 <_main+0x19>
   3a: 8b 45 fc                     	mov	eax, dword ptr [rbp - 4]
   3d: 5d                           	pop	rbp
   3e: c3                           	ret
\end{lstlisting}

b. Il y a donc 17 instructions et le programme occupe \texttt{0x3e}+1 soit 63 octets en mémoire.\\

c. Il suffit de lire:
\begin{center}
\begin{lstlisting}[style=customasm]
1: 48 89 e5             	mov	rbp, rsp
\end{lstlisting}
\end{center}

d. Les instructions qui occupent le plus de mémoire sont les instructions \texttt{mov} correspondant aux initialisations des variables \texttt{i} (2 fois) et \texttt{j} à 0.
Comme ce sont des \texttt{int}, on réserve immédiatement 4 octets (32 bits): c'est de l'adressage immédiat.

\subsection{Exercice 7}
a. Le stockage en RAM des valeurs de \texttt{i} et \texttt{s} initialisées à 0 est enlevé. À la place, on trouve la commande \texttt{test edi, edi} qui agit comme un \texttt{bitwise and} ("et" bit à bit).
La valeur de véracité de \texttt{edi} $\wedge$ \texttt{edi} est toujours \textit{vrai} (donc le test vaut 1), sauf quand $\texttt{edi}=0$, auquel cas la valeur est \textit{faux} (et le test vaut 0).
Cela permet de mettre à jour tous les flags concernés (par exemple ZF vaudra 0 si \texttt{edi} est non nul), mais également de stocker les valeurs de \texttt{i} et \texttt{s} dans des registres.\\

b. Dans le \texttt{main}, on enlève des opérations inutiles telles que \texttt{sub	rsp, 16} et \texttt{add	rsp, 16} et l'assignation \texttt{int count = 100000000} est transcrite en une seule commande. Suivant les architectures, l'appel de la fonction \texttt{sum} est oublié aussi, puisque le résultat est inutilisé, de même que l'instanciation de \texttt{count}.\\

c. On modifie le \texttt{main} :
\begin{lstlisting}[style=CStyle]
int main()
{
    int a = 0;
    int count = 100000000;
    a += sum(count);
}
\end{lstlisting}

d. Un changement est l'utilisation de la commande \texttt{lea} qui fait presque la même opération que \texttt{mov} : \texttt{lea dest source} met l'adresse de \texttt{source} dans \texttt{dest}. Ainsi, \texttt{lea dest [source]} est équivalent à \texttt{mov dest source}, et c'est ce qui est utilisé dans le code optimisé.
\texttt{lea} est pratique car elle permet de faire directement les calculs à la volée dans l'argument, comme par exemple \texttt{lea ecx, [edx + eax*4]}. \\
On note aussi l'utilisation du registre \textit{destination index} \texttt{rdi} dans le code optimisé, qui n'apparait pas dans le code non optimisé.\\
Concernant la boucle, elle est donnée par le code suivant:
\begin{lstlisting}[style=customasm]
lea	eax, [rdi - 1]
lea	ecx, [rdi - 2]
imul	rcx, rax
shr	rcx
lea	eax, [rcx + rdi]
add	eax, -1
pop	rbp
ret
\end{lstlisting}
Le compilateur effectue directement l'opération\footnote{La division par 2 se fait avec l'opération \textit{shift right}, \texttt{shr}, parfois notée \texttt{>>} dans d'autres langages.} :
\begin{equation*}
    \texttt{rcx} = \frac{(\texttt{rdi}-1)(\texttt{rdi}-2)}{2} + (\texttt{rdi}-1) = \displaystyle\sum_{i=1}^{\texttt{rdi-1}}i
\end{equation*}
Enfin, grâce au test sur \texttt{edi}, on saute directement à la fin de la fonction si $\texttt{edi} = 0$, ce qui n'est pas fait dans le code non optimisé, puisqu'on utilise un \texttt{cmp} peu importe la valeur de \texttt{edi}.\\

e. La seule différence obtenue\footnote{Tous les codes sont sur \href{https://github.com/VTrelat/ComputerArchitecture/tree/main/c}{GitHub}.} est la suppression de l'appel à la fonction \texttt{sum} et l'instanciation de \texttt{count} par \texttt{edi}.\\

f. Comme \texttt{count} n'est plus instancié dans le code assembleur avec un niveau 2 d'optimisation, on n'observe aucun changement (\texttt{essai avec \texttt{count=5}}).

g. L'assembleur semble utiliser des méthodes complexes similaires au cas de la somme des entiers. On sait par exemple que la somme des carrés peut s'écrire de la manière suivante :
\begin{equation*}
    \sum_{i=1}^{n-1} i^2 = \frac{n(n-1)(2n-1)}{6}
\end{equation*}
De même, la somme des cubes s'écrit :
\begin{equation*}
    \sum_{i=1}^{n-1} i^2 = (\frac{(n-1)(n-2)}{2})^2
\end{equation*}
On reconnait des opérations similaires au cas de la somme des entiers, néanmoins les expressions ci-dessus ne ressortent pas explicitement.\\

\subsection{Exercice 8}

a. On souhaite faire l'opération $\texttt{rax} \leftarrow \min(4~\texttt{rax}+5, 8~\texttt{rbx}+7)$:
\begin{lstlisting}[style=customasm]
; rax <- 4*rax+5
mul rax, 4
add rax, 5

; rbx <- 8*rbx+7
mul rbx, 8
add rbx, 7

mov dword ptr [rbp - 4], rax
mov dword ptr [rbp - 8], rbx
mov rax, dword ptr [rbp - 4]

cmp rax, dword ptr [rbp - 8] ; performs 4*rax+5 - 8*rbx+7
jge LBB0_1 ; jump if >= 0

jmp LBB0_2

LBB0_1 ; case 4*rax+5 >= 8*rbx+7
mov rax, dword ptr [rbp - 8] ; rax <- 8*rbx+7

LBB0_2 ; case 4*rax+5 < 8*rbx+7 but rax already holds 4*rax+5
skip ahead
\end{lstlisting}

b. On souhaite faire l'opération suivante:\\
\begin{lstlisting}[style=CStyle]
while(rax < rcx){rax += rbx;}
\end{lstlisting}
On écrit le code assembleur suivant:\\
\begin{lstlisting}[style=customasm]
LBB0_1
cmp rax, rcx
jge LBB0_2 ; rax >= rcx

add rax, rbx ; rax <- rax + rbx
jmp LBB0_1

LBB0_2
skip ahead
\end{lstlisting}

c. On veut effectuer l'opération suivante:
\begin{lstlisting}[style=CStyle]
if(rax % 4 == 0){rcx = 1;}
\end{lstlisting}

On écrit le code assembleur suivant:
\begin{lstlisting}[style=customasm]
mov edi, 4
div edi
cmp rdx, 0
jne LBB0_1
mov rcx, 1

LBB0_1
skip ahead
\end{lstlisting}
Il est nécessaire de préciser comment fonctionne \texttt{div}.
Lorsqu'on effectue l'opération \texttt{div $a$} où $a$ est un registre, on divise l'entier représenté par le mot écrit sur le segment \texttt{rdx:rax} par la valeur dans $a$. Le quotient est stocké dans \texttt{rax} et le reste dans \texttt{rdx}, d'où la comparaison directe sur \texttt{rdx}.

\pagebreak
\section{Chapitre 5}
\subsection{Exercice 1}
a. Le premier saut conditionnel (l.4-5 en assembleur) correspond au \textit{if} (l.5 en C).\\
Le deuxième saut conditionnel (l.8-9 en assembleur) correspond à la comparaison \texttt{i < n} dans la boucle \textit{for} (l.4 en C).\\

b. \begin{itemize}
    \item[(a)] Les erreurs de prédiction se font aux indices 3, 4, 8, 9, 11, 13, 15, 16, 17, 18, 19
    \item[(b)] Les erreurs de prédiction se font aux indices 0, 1, 3, 4, 8, 9, 11, 13, 15, 16, 17, 18, 19
\end{itemize}

\subsection{Exercice 2}
a. On obtient les résultats suivants:
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=7cm,
            legend pos = north west,
            xlabel=threshold,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch5/ex2a};
        \end{axis}
    \end{tikzpicture}
\end{figure}

\begin{itemize}
    \item[(a)] Oui !\\
    \item[(b)] Le facteur multiplicatif est d'environ 3.\\
    \item[(c)] Le fait que le pire cas se trouve pour des valeurs de seuil autour de 50 est dû au fait que pour ces valeurs, le prédicteur a une chance sur deux de se tromper. Le nombre de pénalité est donc plus élevé et l'exécution est plus longue.\\
\end{itemize}

b. On obtient les résultats suivants:
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=7cm,
            legend pos = north west,
            xlabel=threshold,
            ymin = 12000000,
            ymax = 18500000,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch5/ex2b};
        \end{axis}
    \end{tikzpicture}
\end{figure}


\end{document}