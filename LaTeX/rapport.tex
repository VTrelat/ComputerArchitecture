\documentclass[11pt, a4 paper]{article}
\usepackage[french]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multicol}
\usepackage{circuitikz}
\usepackage{pgfplots}
\usepackage{framed}
\usepackage{xcolor,colortbl}


\usetikzlibrary{babel}
\usetikzlibrary{backgrounds}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}
\definecolor{lightgreen}{rgb}{0.94,1,0.94}
\definecolor{lightblue}{rgb}{0.94,0.94, 1}
\definecolor{lightred}{rgb}{1,0.94,0.94}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.92,0.92,0.95}

\newcommand{\halmos}{\hfill$\blacksquare$}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,     
    frame=single,    
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}

\begin{document}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .2\textwidth]{img/logoartem.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Architecture des ordinateurs}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Erwan LEBAILLY | Vilavane LY | Vincent TRÉLAT | Benjamin ZHU
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\tableofcontents
\pagebreak

\section{Chapitre 1}
\subsection{Exercice 1}
Avec la convention $0 \leftrightarrow \texttt{faux}$ et $1 \leftrightarrow \texttt{vrai}$, $0 \wedge 1 = \texttt{faux}$.

\subsection{Exercice 2}
On donne la table de $c_0$ :
\begin{center}
    $c_0 \colon$
    \begin{tabular}{||c | c | c ||} 
     \hline
     $a_0 \backslash b_0$ & 0 & 1 \\ [0.5ex] 
     \hline\hline
     0 & 0 & 1  \\ 
     \hline
     1 & 1 & 0 \\
     \hline
    \end{tabular}
\end{center}
On peut interpréter cette table comme la table de vérité du "ou exclusif", le \textit{xor}. Ainsi, $c_0$ coincide avec $a_0 \oplus b_0 = (a_0 \vee b_0) \wedge (\neg (a_0 \wedge b_0))$.

\subsection{Exercice 3}
a. Montrons que l'opérateur xor $\oplus$ est associatif et commutatif :\\
Soient $a, b, c \in \{0, 1\}$.\\

\textbf{Associativité :} on donne ci-dessous la table de vérité de $(a \oplus b) \oplus c$ et $a \oplus (b \oplus c)$:
\begin{center}
    \begin{tabular}{||c | c | c | c | c | c ||} 
     \hline
     $a$ & $b$ & $c$ & $a \oplus b$ & $(a \oplus b) \oplus c$ & $a \oplus (b \oplus c)$ \\ [0.5ex] 
     \hline\hline
    %a   b   c  a+b  r1 r2
     0 & 0 & 0 & 0 & 0 & 0\\ 
     0 & 0 & 1 & 0 & 1 & 1\\ 
     1 & 0 & 0 & 1 & 0 & 0\\ 
     1 & 0 & 1 & 1 & 0 & 0\\ 
     0 & 1 & 0 & 1 & 1 & 1\\ 
     0 & 1 & 1 & 1 & 0 & 0\\ 
     1 & 1 & 0 & 0 & 0 & 0\\ 
     1 & 1 & 1 & 0 & 1 & 1\\ 
     \hline
    \end{tabular}
\end{center}

\textbf{Commutativité :} on donne ci-dessous la table de vérité de $a \oplus b$ et $b \oplus a$:
\begin{center}
    \begin{tabular}{||c | c | c | c ||} 
     \hline
     $a$ & $b$ & $a \oplus b$ & $b \oplus a$ \\ [0.5ex] 
     \hline\hline
    %a   b  a+b  b+a
    0 & 0 & 0 & 0 \\
    0 & 1 & 1 & 1 \\
    1 & 0 & 1 & 1 \\
    1 & 1 & 0 & 0 \\
     \hline
    \end{tabular}
\end{center}

Enfin, $a \oplus a = 0$ et $a \oplus 0 = a$.\\

On peut maintenant montrer le résultat demandé :\\
\begin{equation*}
    d = a \oplus c = a \oplus (a \oplus b) = a \oplus a \oplus b = b
\end{equation*}

\begin{equation*}
    e = b \oplus c = b \oplus (a \oplus b) = b \oplus a \oplus b = a
\end{equation*}

\halmos

b. On donne ci-dessous le circuit correspondant :
\begin{center}
    \begin{circuitikz}[framed, scale=1.5]
        % \draw (0,0) node[ american and port ] {};
        % \draw (0,2) node[ american or port ] {};
        % \draw (0,6) node[ american not port ] {};
    
        \draw (0,1) node (a) {a};
        \draw (7,1) node (d) {d};
        \draw (0,-1) node (b) {b};
        \draw (7,-1) node (e) {e};
        \draw (3,0) node[ american xor port ] (xor1) {};
        \draw (6,1) node[ american xor port ] (xor2) {};
        \draw (6,-1) node[ american xor port ] (xor3) {};
        
        \draw (.2, 1) -- (xor1.in 1);
        \draw (.2, 1) -| (xor2.in 1);
        \draw (xor1.out) |- (xor2.in 2);
        \draw (xor1.out) |- (xor3.in 1);
        \draw (.2, -1) -- (xor1.in 2);
        \draw (.2, -1) -| (xor3.in 2);
        
        \draw (xor2.out) -| (6.8,1);
        \draw (xor3.out) -| (6.8,-1);
        
    \end{circuitikz}
\end{center}

\subsection{Exercice 4}
a. On écrit le code suivant :\\
\begin{lstlisting}[style=CStyle]
int main()
    {
        printf("Sizeof int: %lu octets\n", sizeof(int));
        printf("Sizeof short: %lu octets\n", sizeof(short));
        printf("Sizeof char: %lu octets\n", sizeof(char));
        return 0;
    }
\end{lstlisting}

La sortie est la suivante :\\
\begin{lstlisting}[style=CStyle]
    Sizeof int: 4 octets
    Sizeof short: 2 octets
    Sizeof char: 1 octets
\end{lstlisting}

b. On écrit le code suivant :
\begin{lstlisting}[style=CStyle]
int main()
    {
        int a = pow(2, 31);
        int b = pow(2, 31);
        int c = a + b;
        printf("%d\n", c);
        return 0;
    }
\end{lstlisting}

La sortie affiche 0, ce qui correspond bien à $2^{32} \mod(2^{32})$

\subsection{Exercice 5}
On donne ci-dessous l'écriture binaire sur 4 et 8 bits de 0, 1, -1 et -2:
\begin{center}
    \begin{tabular}{c | c | c} 
    $x$ & 4 bits & 8 bits\\
        \hline
        \hline
    0 :& 0000 & 0000 0000\\ 
    1 :& 0001 & 0000 0001\\
    -1 :& 1111 & 1111 1111\\
    -2 :& 1110 & 1111 1110\\
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. $m_1 = 0001$ et $m_{-1} = 1001$.

b. En abusant de la notation + pour des mots : $m_0 = m_1 + m_{-1} = 1010$.

c. En suivant la règle de signes, 1010 est l'encodage de -2.

\subsection{Exercice 7}
Soit $b$ un nombre de bits. Soit $x$ un entier relatif qu'on souhaite représenter sur $b$ bits.\\
Si $x \geq 0$, alors l'encodage de $x$ correspond à une écriture dans $[0, 2^{b-1}-1]$, alors cette écriture commence par un zéro (de 00...0 à 01...1).
Si $x < 0$, alors $2^b - x \in [2^{b-1}, 2^b-1]$ (soit de 10...0 à 11...1), son écriture commence par un 1.

\halmos


\subsection{Exercice 8}
Dans le premier code, on dispose de 2 cases mémoires différentes.
Le résultat affiché est -106 pour la valeur de d, ce qui est normal puisque d est signé.\\
Dans le deuxième code, on utilise une seule case mémoire à travers l'utilisation de deux pointeurs, un signé et un non signé.
Le résultat affiché est identique au premier code.\\
Cela permet de montrer que la mémoire est "non typée", l'interprétation de la valeur mémoire dépend directement du type de l'objet qui lit cette valeur.

\subsection{Exercice 9}
a. 10 s'écrit $2\times5$ et toute puissance de 2 s'écrit $2^k$ où $k\in \mathbb{N}$.\\
Ainsi, si $x \in 2^{\mathbb{N}}$ (par abus de langage) est divisible par 10, alors $x$ contient au moins 2 et 5 dans sa décomposition en facteurs premiers, ce qui donne une contradition avec la propriété précédemment énoncée.\\

\halmos

b. Supposons que $0.1$ soit représentable sur $kl$ bits.
Alors, d'après le résultat du cours, $2^l \times 0.1$ est un entier, autrement dit $2^l$ est divisible par 10.
D'après la question précédente, c'est impossible.

\halmos

\subsection{Exercice 10}
L'écriture binaire approchée de $0.1$ est $0.0001~1001_2$, de valeur décimale $0.09765625$.

\subsection{Exercice 11}
a. On écrit la fonction suivante en C :

\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            printf("(%d, %d) : %s\n", i, j, (a+b == c)?"true":"false");
        }
    } 
    return 0;
}
\end{lstlisting}

La sortie affichée contient, entre autres, les résultats suivants :
\begin{multicols}{2}
    \begin{itemize}
        \item[$\bullet$] (1, 4) : true
        \item[$\bullet$] (1, 5) : true
        \item[$\bullet$] (1, 6) : false
        \item[$\bullet$] (1, 7) : true
        \item[$\bullet$] (1, 8) : false
        
        \item[$\bullet$] (3, 4) : false
        \item[$\bullet$] (3, 5) : true
        \item[$\bullet$] (3, 6) : false
        \item[$\bullet$] (3, 7) : true
        \item[$\bullet$] (3, 8) : true
    \end{itemize}    
\end{multicols}

b. On modifie seulement la ligne d'affichage dans le code\footnote{Comme un \texttt{int} est codé sur 4 octets, on donne 16 caractères à chaque affichage.} :
\begin{lstlisting}[style=CStyle]
printf("%.16f + %.16f = %.16f\n", a, b, c);
\end{lstlisting}
On donne seulement les résultats pour les 5 premiers couples ci-dessus :
\begin{lstlisting}[style=CStyle]
0.1000000014901161 + 0.4000000059604645 = 0.5000000000000000
0.1000000014901161 + 0.5000000000000000 = 0.6000000238418579
0.1000000014901161 + 0.6000000238418579 = 0.6999999880790710
0.1000000014901161 + 0.6999999880790710 = 0.8000000119209290
0.1000000014901161 + 0.8000000119209290 = 0.8999999761581421
\end{lstlisting}

c. On remarque que pour une addition, l'égalité \texttt{a+b==c} est vérifiée lorsque \texttt{a} et \texttt{b} sont représentables, ou quand l'un des deux seulement l'est.
Dans le second cas, l'erreur de représentation n'a pas eu d'impact sur le résultat puisque c'est la seule erreur du calcul.
Ainsi l'égalité reste vraie.\\
En revanche, dès que les deux flottants ne sont pas représentables, les erreurs s'accumulent et alors la représentation de \texttt{c} peut différer de la valeur de \texttt{a+b}.\\

Dans un cas général si on prend $x, y \in \mathbb{R}$ tels que $x=y$, on aura \texttt{x==y} quand $x$ et $y$ sont représentables sur un nombre de bits donné
    \footnote{
        Il faut tout de même faire attention à la précision.
        Augmenter la précision ne rendra pas les calculs exacts pour autant.
    }.
Dans les autres cas, il est possible d'obtenir un résultat correct mais cela résulte plutôt du hasard.\\

d. On modifie la fonction précédente :
\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            if(a+b!=c){
                int m1 = a+b>c;
                int m2 = a+b+.000001>c+.000001;
                printf("(%d, %d) : %d %d\n", i, j, m1, m2);
            }
        }
    } 
    return 0;
}
\end{lstlisting}

On obtient la sortie suivante :
\begin{lstlisting}[style=CStyle]
// a+b > c is tested before and after adding 1e-6
(1, 6) : 1 1
(1, 8) : 1 1
(3, 4) : 1 1
(3, 6) : 1 1
(4, 3) : 1 1
(6, 1) : 1 1
(6, 3) : 1 1
(6, 8) : 1 1
(7, 9) : 0 0
(8, 1) : 1 1
(8, 6) : 1 1
(9, 7) : 0 0
\end{lstlisting}
On constate que l'ordre est conservé à chaque fois.
Comme $10^{-6}$ n'est pas représentable sur 16 bits ($10^{-6} \approx 2^{-20}$), on simule l'effet de la propagation d'une erreur.\\
On en déduit que des erreurs successives d'arrondi ne bousculent pas l'ordre sur des valeurs arrondies.
Toutefois ici on effectue le même calcul des deux côtés.
On peut donc toujours les comparer\footnote{Pas l'égalité.}, même après plusieurs calculs, puisque l'ordre est conservé.
On peut également penser que cela ne provoquera pas d'évolution chaotique ou aléatoire de ces valeurs dans les calculs.
En revanche, pour une suite d'opérations inconnue, cela risque de devenir insignifiant de vouloir comparer deux flottants.

\subsection{Exercice 12}
On note $s_1 = \displaystyle{\sum_{i=1}^{k} \frac{1}{i}}$ et $s_2 = \displaystyle{\sum_{i=k}^{1} \frac{1}{i}}$.\\
On écrit la fonction suivante :

\begin{lstlisting}[style=CStyle]
int main() {
    float s1 = 0.0, s2 = 0.0;
    long k = 1000000000;
    for (double i = 1; i<k+1; i++){
        s1 += 1/i;
        s2 += 1/(k+1-i);
    }
    printf("k=%ld\n    s1 = %.16f\n    s2 = %.16f\n", k, s1, s2);
    return 0;
}
\end{lstlisting}

Les résultats sont les suivants :
\begin{lstlisting}[style=CStyle]
k=1000
    s1 = 7.4854784011840820
    s2 = 7.4854717254638672
k=1000000
    s1 = 14.3573579788208008
    s2 = 14.3926515579223633
k=1000000000
    s1 = 15.4036827087402344
    s2 = 18.8079185485839844
\end{lstlisting}
On constate que les résultats diffèrent\footnote{Même plus que ça, on dirait que la série converge !
On connait l'équivalent pour la série harmonique : $H_n \underset{n \to +\infty}{\sim} \gamma + \ln(n)$ où $\gamma \approx 0.5$ est la constante d'Euler.
Pour $n = 10^9$, on devrait donc plutôt être autour de $H_n \approx 21$.} d'autant plus que le nombre d'erreurs successives est grand, ce qui n'est pas étonnant.
Là où le résultat interpelle, c'est que l'ordre de parcours de la somme a un impact conséquent sur le résultat.\\
Cette erreur est due au fait que lorsque le parcours est décroissant, on finit pas les petits nombres.
Ces derniers causent alors des erreurs d'arrondi car leur ordre de grandeur est faible par rapport aux premiers nombres.

\subsection{Exercice 13}
a. La taille d'un \texttt{float} en C est de 4 \textit{bytes}, soit 32 bits :
\begin{itemize}
    \item[$\bullet$] 1 bit de signe
    \item[$\bullet$] 8 bits d'exposant
    \item[$\bullet$] 23 bits de mantisse
\end{itemize}

b. Convertissons d'abord \texttt{0x414BD000} en binaire :
\begin{equation*}
    414BD000_{16} = 01000001010010111101000000000000_2
\end{equation*}
On identifie ensuite les bits de signe, d'exposant et de mantisse :
\begin{equation*}
    \underset{S}{\underbrace{0}}~\underset{E=130}{\underbrace{10000010}}~\underset{T}{\underbrace{10010111101000000000000}}
\end{equation*}
Le biais $b$ valant 127, notre exposant ici vaut $E-b = 3$. Donc, en "écriture binaire à virgule", on obtient :
\begin{equation*}
    1.10010111101 \times 2^3 = \underset{=12}{\underbrace{1100}}.\underset{=0.73828125}{\underbrace{10111101}}
\end{equation*}
Soit finalement :
\begin{center}
    \texttt{0x414BD000}$_{16}$ encode $12.73828125$
\end{center}

c. En suivant le raisonnement inverse, on peut trouver l'exposant et la mantisse de l'encodage de 0.1. On commence par l'écrire en "binaire à virgule" :
\begin{equation*}
    0.1 = 000110011001100110011001101_2
\end{equation*}
On décale la virgule pour trouver l'exposant :
\begin{equation*}
    0.1 = 1.10011001100110011001101_2 \times 2^{-4}
\end{equation*}
Cela donne donc un exposant de $E = b - 4 = 123 = 01111011_2$ sur 8 bits.
Enfin, $0.1 > 0$ donc on met un premier bit à 0. On obtient donc l'encodage suivant -- dont on donne également la valeur décimale réelle -- pour le nombre 0.1 :
\begin{equation*}
    \underset{\text{signe}}{\underbrace{0}}\underset{\text{exposant}}{\underbrace{01111011}}\underset{\text{mantisse}}{\underbrace{10011001100110011001101_2}} = 0.100000001490116119384765625
\end{equation*}

\pagebreak

\section{Chapitre 2}
\subsection{Exercice 1}
a. Lorsqu'on crée par exemple un tableau de taille un milliard, on obtient une erreur similaire à la suivante :
\begin{lstlisting}[style=CStyle]
[1]    54133 segmentation fault  ./a.out
\end{lstlisting}
b. En expérimentant à la main, on trouve qu'on peut créer un tableau de taille maximale 2 096 286.

\subsection{Exercice 2}
On vérifie par exemple qu'on peut créer un tableau de taille un milliard.

\subsection{Exercice 3}
La machine utilisée pour ce TD utilise la convention \textit{little endian}.

\subsection{Exercice 4}
On écrit déjà le code suivant :
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
#include <x86intrin.h>

unsigned long int squareSum(int n){
    unsigned long int tic, toc;
    unsigned int ui;
    int a = 0;
    tic = __rdtscp(&ui);
    for (int i = 0; i < n; ++i){
        a = i * i;
    }
    toc = __rdtscp(&ui);
    return toc - tic;
}
int main(){
    printf("n=%d: %lu tics\n", 1000, squareSum(1000));
    printf("n=%d: %lu tics\n", 10000, squareSum(10000));
    printf("n=%d: %lu tics\n", 1000000, squareSum(1000000));
    printf("n=%d: %lu tics\n", 10000000, squareSum(10000000));
    printf("n=%d: %lu tics\n", 100000000, squareSum(100000000));
    return 0;
}
\end{lstlisting}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c || c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^4$ & $10^6$ & $10^7$ & $10^8$ \\
        \hline
    mesure & 3310 & 42456 & 7134866 & 67719612 & 637584056\\ 
     \hline
    \end{tabular}
\end{center}
On note qu'on semble bien obtenir une relation qui a l'air linéaire, hormis la dernière mesure.

\subsection{Exercice 5}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        1er & 9108 & 835910 & 52244848 & 532734614 & 5350923602\\ 
        \hline
        2ème & 3238 & 685744 & 31633110 & 317468584 & 3161147144\\ 
        \hline
        3ème & 3088 & 322012 & 32683670 & 341747932 & 3100426690\\ 
        \hline
    $\frac{\text{écart max.}}{\text{moyenne}}$ en \% & 117 & 83 & 53 & 53 & 58\\ 
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. On teste la fonction avec la fonction \texttt{test} calculant la somme des premiers carrés. On obtient des résultats cohérents (croissance linéaire).
La fonction \texttt{print\_timing} comprend une amorce qui exécute 10 fois la fonction à tester et moyenne les mesures sur 100 appels.

b. Voici la fonction \texttt{print\_timing}:

\begin{lstlisting}[style=CStyle]
void print_timing(int arg, void (*func)(int), int nb_boot, int nb_call)
{
    // boot up
    for (int i = 0; i < nb_boot; i++)
    {
        func(arg);
    }

    // measure
    unsigned long int tic, toc;
    unsigned int ui;
    tic = __rdtscp(&ui);
    for (int i = 0; i < nb_call; i++)
    {
        func(arg);
    }
    toc = __rdtscp(&ui);

    printf("average time : %lu\n", (toc - tic) / n);
}
\end{lstlisting}

c. Oui.

d. On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    appel$\backslash n$ & $10^3$ & $10^5$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        mesure \texttt{print\_timing} & 4214 & 432308 & 31686176 & 308206789 & 3176004203\\ 
        \hline
    \end{tabular}
\end{center}

\subsection{Exercice 7}
On obtient les résultats suivants (arrondis):
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
        pas & $1$ & $2$ & $3$ & $4$ & $8$ & $16$ & $32$ \\
        \hline
        mesure ($\times 10^6$ tics)& 59 & 61 & 63 & 66 & 83 & 102 & 197 \\ 
        \hline
    \end{tabular}
\end{center}

On peut ainsi tracer les résultats obtenus pour les pas situés entre 1 et 1000:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=7cm,
            legend pos = south east,
            xlabel=step,
            ylabel=tics]
        \addplot[
            domain = 60:1000,
            samples = 20,
            smooth,
            thin,
            dashed,
            green!60!black,
        ] {600000000*(1-exp(-x/130))};
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex7.dat};
        \legend{
            Model,
            Measures, 
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
On remarque que les temps d'accès semblent converger\footnote{Plus précisément -- car on sait qu'il est impossible que cela converge -- on semble observer une croissance logarithmique.}!
Pour mieux l'illustrer, on trace par dessus les mesures la fonction suivante (en vert sur le graphique):
\begin{equation*}
    x \mapsto 6\times 10^8 (1-e^{-\frac{x}{130}})
\end{equation*}

% On mesure des temps d'accès dont la proportion d'accès hors-cache augmente

\subsection{Exercice 8}

a. On écrit d'abord les deux fonctions suivantes\footnote{Il faut inclure les bibliothèques \texttt{stdlib} et \texttt{time} au début du code, et initialiser le \textit{seed} avec \texttt{srand(unsigned int)time(NULL)}.} :
\begin{lstlisting}[style=CStyle]
void access_seq(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[i];
    }
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
void access_rand(int *tab, int n)
{
    int tmp;
    for (int i = 0; i < n; i++)
    {
        tmp = tab[(unsigned long int)rand() % 1000000000];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 5111 & 5316032 & 44992606 & 450441905 & 4609590108\\ 
        \hline
        \texttt{access\_rand} & 3855618 & 139739559 & 1386369206 & 14181946914 & 148526968620 \\ 
        \hline
    \end{tabular}
\end{center}

b. On constate que la fonction \texttt{access\_rand} est (très largement, d'un facteur 30 environ) plus lente que la fonction \texttt{access\_seq}!
Est-ce réellement le cas ? Pour l'instant, on ne peut pas répondre à cette question, toutefois on peut facilement se rendre compte qu'on mesure bien trop de choses.
En effet, à chaque accès aléatoire, on appelle -- donc on mesure -- la fonction \texttt{rand}, qui prend visiblement un temps non négligeable.


c. On modifie légèrement les fonctions de mesure\footnote{Tous les codes sont disponibles sur \href{https://github.com/VTrelat/ComputerArchitecture/tree/main/c}{GitHub}.
Attention toutefois, l'exécution du code correspondant à cette mesure peut prendre plusieurs dizaines de minutes et nécessite au moins une dizaine de Go de RAM.} et on écrit la fonction suivante :
\begin{lstlisting}[style=CStyle]
void access_aux(int *tab, unsigned long int *aux, unsigned long int n)
{
    int tmp;
    for (register unsigned long int i = 0; i < n; i++)
    {
        tmp = tab[aux[i]];
    }
}
\end{lstlisting}
On obtient les temps suivants:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^6$ & $10^7$ & $10^8$ & $10^9$ \\
        \hline
        \hline
        \texttt{access\_seq} & 4298 & 4263336 & 42850857 & 444757816 & 4356153500 \\
        \hline
        \texttt{access\_rand} & 3463 & 8848371 & 377748557 & 5385496993 & 97091291039 \\
        \hline
    \end{tabular}
\end{center}

On obtient les courbes suivantes:
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5.5cm,
            legend pos = north west,
            xlabel=size,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch2/ex8_1.dat};
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch2/ex8_2.dat};
        \legend{
            Sequential, 
            Random,
        }
        \end{axis}
    \end{tikzpicture}
\end{center}
Passons rapidement sur l'étude de ces courbes.\\
\textbf{Accès séquentiel}: on peut définir la fontion
\begin{equation*}
    t_{\text{seq}} \colon n \mapsto \tau_\text{seq} n
\end{equation*}
donnant une estimation temps mis pour réaliser des accès séquentiels en mémoire, où $\tau_\text{seq} \approx 4.298$.
Le temps d'un accès séquentiel en mémoire, \textit{i.e.} sur des cases mémoires successives, est donc d'environ 4 \textit{tics}\footnote{Le temps de la mesure augmente linéairement avec le nombre d'accès mémoire.
En moyennant, on obtient bien un temps constant par mesure.}. C'est très rapide !\\

\noindent
\textbf{Accès aléatoire}: on peut de même définir la fontion
\begin{equation*}
    t_{\text{rand}} \colon n \mapsto \tau_\text{rand} n
\end{equation*}
où $\tau_\text{rand} \approx 101.9$. Ainsi, un accès aléatoire dans la mémoire prendra environ 102 \textit{tics}.
C'est approximativement 20 fois plus long que pour un accès séquentiel, toutefois cela reste du temps constant !
La différence peut déjà s'expliquer par le fait que pour "sauter" d'une position à une autre, le pointeur qui fait office de tête de lecture doit faire un calcul arithmétique pour déterminer l'adresse mémoire de la case sur laquelle il doit se rendre.
Cela peut nécessiter une soustraction, par exemple, ou encore un modulo, qui est tout de même assez coûteux (quelques dizaines de \textit{tics}).

\begin{framed}
    \textbf{Conclusion} :
    Néanmoins, la vraie différence vient d'un autre phénomène qui est la mise en cache de données\footnote{cf Chapitre 3}.
    Lorsqu'on fait des accès séquentiel, on charge des blocs en cache, et on fait une suite d'accès en cache, ce qui est rapide.
    Lorsqu'on fait une suite d'accès aléatoires, on fait des accès hors-cache presque à chaque nouvel accès, puisque la probabilité que deux accès consécutifs concernent des données présentes dans un même bloc est beaucoup plus faible.
\end{framed}

\pagebreak

\section{Chapitre 3}
\subsection{Exercice 1}
\noindent
\texttt{0xAE01D500} et \texttt{0xAE01D501} \hfill Oui \hfill \\
\texttt{0xAE01D500} et \texttt{0xAE01D4FF} \hfill Non \hfill \\
\texttt{0xAE01D500} et \texttt{0xAE01D580} \hfill Non \hfill \\
\texttt{0xAE01D53D} et \texttt{0xAE01D542} \hfill Oui \hfill \\
\texttt{0xAD01F506} et \texttt{0xAE01D508} \hfill Non \hfill \\
\texttt{0xAE01D55F} et \texttt{0xAE01D560} \hfill Oui \hfill \\

\subsection{Exercice 2}
On vérifie déjà qu'une instance de type \texttt{noeud} occupe bien 24 octets avec la commande:\\
\begin{lstlisting}[style=CStyle]
printf("sizeof noeud: %lu o", sizeof(struct noeud));
\end{lstlisting}
Le fait que la somme des tailles diffère de la taille de la somme (de la structure) provient de la compilation : le compilateur fait de l'alignment (\textit{padding}) sur des multiples de 8 afin qu'un élément se trouve toujours en début de bloc.
Ainsi, un \texttt{noeud} occupe une taille de $20+4=24$ octets.\\

a. On peut stocker $\frac{32\times1024}{64} = 512$ blocs.
Le noeud 14 par exemple commence à l'adresse \texttt{0xAE01D53C} et finit à l'adresse \texttt{0xAE01D54F}.
Or, le premier bloc se termine à l'adresse \texttt{0xAE01D540}\footnote{\texttt{0xAE01D500} décalé de 64 octets}, soit au "milieu" du noeud 14.\\

b. On commence par lire le noeud 1, qui charge -- c'est donc un accès hors-cache -- le bloc contenant la fin du noeud 20, le 1, le 25 et le début du noeud 22.
Ensuite, on lit le noeud 2 qui charge le bloc -- accès hors-cache -- qui contient les noeuds 2, 9 et le début du noeud 14.
On fait de même pour le noeud 3, puis pour le 4, on doit charger deux blocs car le noeud 4 est à cheval sur ces deux blocs : on charge donc les noeuds 27 (fin), 10, 24, 4, 21 et 13.
On continue jusqu'au noeud 8, qui est dans le bloc du noeud 7, donc pas d'accès hors-cache.\\
Pour résumer, sur les 27 accès, les accès hors-cache sont : 1, 2, 3, 4, 5, 6, 7 et 16.

\subsection{Exercice 3}

On obtient les résultats suivants\footnote{Sous Mac, on peut accéder à ce genre d'informations par la commande \texttt{sysctl}.
En particulier, ici on peut utiliser la commande \texttt{sysctl -a | grep hw}.}:
\begin{center}\label{ex3:tab}
    \begin{tabular}{| c || c | c | c | c |}
        \hline
    & L1 instruction & L1 données & L2 & L3 \\
        \hline
    Taille mémoire & 32768 & 32768 & 262144 & 16777216 \\
        \hline
    Ligne de cache & 64 & 64 & 64 & 64 \\
        \hline
    Associativité & 8 & 8 & 4 & 16 \\
        \hline
    \end{tabular}
\end{center}

\subsection{Exercice 4}
On cherche à mettre en évidence la taille du cache L1 et du cache L2.
Pour cela, on va regarder les temps mis pour parcourir un tableau en colonnes et si on observe un pic pour une taille $N$ de tableau, cela signifie que le cache est de taille $64\times N$ ko.
En l'occurrence, on s'attend à voir un pic autour de $N = \frac{32768}{64} = 512$ pour L1 et $N = \frac{262144}{64} = 4096$ pour L2.

\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5cm,
            legend pos = north west,
            xlabel=$N$,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex4a};
        \node at (axis cs:480,3100)(B){$N=512$};
        \node at (axis cs:512,3187)(C){};
        \draw [->](B.east)--(C.west);
        \end{axis}
    \end{tikzpicture}
    \caption{Mise en évidence du cache L1}
\end{figure}

\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=5cm,
            legend pos = north west,
            xlabel=$N$,
            ylabel=tics]
        \addplot[
            semithick,
            red,
        ] file[skip first] {../c/ch3/ex4b};
        \node at (axis cs:4085,115000)(B){$N=4096$};
        \node at (axis cs:4096,125000)(C){};
        \draw [->](B.east)--(C.west);
        \end{axis}
    \end{tikzpicture}
    \caption{Mise en évidence du cache L2}
\end{figure}

On donne quelques valeurs numériques autour de $N = 4096$ ci-dessous:
\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c |}
        \hline
    n & 4094 & 4095 & 4096 & 4097 & 4098 & 4099 \\
    \hline
    en ligne & 59737 & 54042 & 52042 & 56912 & 61912 & 62952 \\
    \hline
    en colonne & 61302 & 63239 & 126933 & 97693 & 78726 & 67656 \\
    \hline
    \end{tabular}
\end{center}

\subsection{Exercice 5}
Voir le tableau de l'\nameref{ex3:tab}\footnote{Note : sous Mac, on obtient seulement la valeur de l'associativité pour le cache L2 : \texttt{machdep.cpu.cache.L2\_associativity: 4
}.
Toutes les autres valeurs ont été obtenues sur la fiche technique du processeur fournie par Intel, en l'occurrence un \texttt{Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz}.}.\\


\subsection{Exercice 6}
% blocs : [2, 9, 19, 14], [14, 6, 15, 26], [26, 23, 16, ...]
On redonne ci-dessous les blocs de l'exercice 2 :\\
\begin{center}
    \begin{tabular}{| c | c || c | c || c | c |}
        \rowcolor{lightgrey}
        \hline
        $p$ & addresse & $p$ & addresse & $p$ & addresse \\
        \hline
        \hline
        \rowcolor{lightgreen}
        2 & \texttt{0xAE01D500} & 3 & \texttt{0xAF01D900} & 11 & \texttt{0xBF01DD00} \\
        \hline
        \rowcolor{lightgreen}
        9 & \texttt{0xAE01D514} & 17 & \texttt{0xAF01D914} & 5 & \texttt{0xBF01DD14} \\
        \hline
        \rowcolor{lightgreen}
        19 & \texttt{0xAE01D528} & 12 & \texttt{0xAF01D928} & 18 & \texttt{0xBF01DD28} \\
        \hline
        \rowcolor{lightgreen}
        14 & \texttt{0xAE01D53C} & 20 & \texttt{0xAF01D93C} & 27 & \texttt{0xBF01DD3C} \\
        \hline
        \hline
        \rowcolor{lightblue}
        14 & \texttt{0xAE01D53C} & 20 & \texttt{0xAF01D93C} & 27 & \texttt{0xBF01DD3C} \\
        \hline
        \rowcolor{lightblue}
        6 & \texttt{0xAE01D550} & 1 & \texttt{0xAF01D950} & 10 & \texttt{0xBF01DD50} \\
        \hline
        \rowcolor{lightblue}
        15 & \texttt{0xAE01D564} & 25 & \texttt{0xAF01D964} & 24 & \texttt{0xBF01DD64}\\
        \hline
        \rowcolor{lightblue}
        26 & \texttt{0xAE01D578} & 22 & \texttt{0xAF01D978} & 4 & \texttt{0xBF01DD78}\\
        \hline
        \hline
        \rowcolor{lightred}
        26 & \texttt{0xAE01D578} & 22 & \texttt{0xAF01D978} & 4 & \texttt{0xBF01DD78}\\
        \hline
        \rowcolor{lightred}
        23 & \texttt{0xAE01D58C} & 8 & \texttt{0xAF01D98C} & 21 & \texttt{0xBF01DD8C}\\
        \hline
        \rowcolor{lightred}
        16 & \texttt{0xAE01D5A0} & 7 & \texttt{0xAF01D9A0} & 13 & \texttt{0xBF01DDA0}\\
        \hline
    \end{tabular}
\end{center}
Si on dispose d'un cache de 1 Ko et d'un niveau d'associativité 2, on a $\frac{1024}{64} = 16$ blocs, 128 octets par sous-cache, soit 2 blocs et $\frac{1024}{128} = 8$ sous-caches.\\
Les couleurs dans le tableau représentent les blocs qui sont dans le même sous-cache.
Par exemple, pour 2, 3, 11, 9, 17, 5, etc:
\begin{itemize}
    \item[$\bullet$] \texttt{(0xAE01D500 >> 6) mod 8 = 4}
    \item[$\bullet$] \texttt{(0xAF01D900 >> 6) mod 8 = 4}
    \item[$\bullet$] \texttt{(0xAE01D500 >> 6) mod 8 = 4}
    \item[$\bullet$] \dots\\
\end{itemize}
% Sous caches :
% 1 : [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27], [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27], [2, 9, 19, 14], [3, 17, 12, 20], [11, 5, 18, 27]
% 2 : [20, 1, 25, 22], [27, 10, 24, 4], [14, 6, 15, 26], [20, 1, 25, 22]
% 3 : [22, 8, 7], [4, 21, 13], [26, 23, 16], [22, 8, 7]

Le premier appel qui est fait en cache est l'accès de 8, qui est dans le bloc chargé par 7.
Le premier appel hors-cache non trivial est l'accès à 9, qui est bien dans le même bloc que 2, mais les accès à 3 et à 5 ont écrasé le premier bloc entre temps.\\
En résumé :
\begin{itemize}
    \item[$\bullet$] \textit{cache-miss} : 1, 2, 3, 4, 5, 6, 7, 9, 12, 13, 16, 18, 19, 20, 22, 25, 27
    \item[$\bullet$] \textit{cache-hit} : 8, 10, 11, 14, 15, 17, 21, 23, 24, 26
\end{itemize}


% Ex 6 : cache 32 ko = 32 * 2**10
% 64 o * 2 = 128 o par sous-cache
% 32*2^10 / 2^7 = 256 sous-cache

% 2 octets séparés d'un multiple de 32768 en mémoire seront dans le même sous-cache

% cf ex2 : le bloc contenant 1 et le bloc contenant 11 sont dans le même sous-cache
%         3 et 27
%         20
%         26 et 21
%         22

% Corriger le sujet : si on a 1 ko de cache -> contient 1024 / 64 = 16 blocs et 1024/128 = 8 sous-caches
%             2, 3, 11 sont dans le même sous-cache
%             14, 20, 27
%             26, 22, 4
% /!\ 9 fait un cache-miss car on a chargé 3 et 5 entre temps.

\subsection{Exercice 7}
On trace les temps successifs obtenus pour les trois expériences (N valant 1000000, 1048576 puis 1300000):
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7a};
        \node at (axis cs:500,550)(B){$N=$1 000 000};
        \end{axis}
    \end{tikzpicture}
\end{figure}
\vspace{-20pt}
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7b};
        \node at (axis cs:500,550)(B){$N=$1 048 576};
        \end{axis}
    \end{tikzpicture}
\end{figure}
\vspace{-20pt}
\begin{figure}[!h]
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=6cm,
            legend pos = north west,
            xlabel=$i$,
            ymin=180,
            ymax=600,
            ylabel=tics]
        \addplot[
            semithick,
            blue,
        ] file[skip first] {../c/ch3/ex7c};
        \node at (axis cs:500,550)(B){$N=$1 300 000};
        \end{axis}
    \end{tikzpicture}
\end{figure}

On constate que pour $N=2^{20}$, les temps sont globalement toujours supérieurs aux deux autres cas. En effet, on peut calculer les temps moyens $T(N)$ dans chaque cas :
\begin{align*}
    T(1000000) = 227.726\\
    T(1048576) = 252.717\\
    T(1300000) = 239.417
\end{align*}

Pourquoi une recherche dichotomique dans un tableau de taille $2^{20}$ met un temps environ 10\% plus long qu'un tableau de taille 1 300 000 ?\\
Ce phénomène est lié au phénomène d'associativité dans le système de cache de l'architecture de la machine.
En effet, pour un tableau dont la taille est une puissance de 2, la taille de chaque sous-tableau est encore une puissance de 2.
Or, le nombre de sous-caches ici est aussi une puissance de 2 -- mais beaucoup plus petite, d'où le $2^{20}$ -- donc à chaque accès au milieu du tableau tombe sur une puissance de 2.
Or, on sait que les blocs mis en cache sont mis dans le sous-cache dont le numéro est calculé "modulo le nombre de sous-cache".
Ainsi, on écrase à chaque étape la valeur précédemment mise en cache.
On ne fait donc (presque) que des accès hors-cache, d'où le temps plus long.

\end{document}