\documentclass[a4 paper, 12pt]{article}
\usepackage[french]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,     
    frame=single,    
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}


\begin{document}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .2\textwidth]{img/logoartem.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Architecture des ordinateurs}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Erwan LEBAILLY | Vilavane LY | Vincent TRÉLAT | Benjamin ZHU
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\tableofcontents
\pagebreak

\section{Chapitre 1}
\subsection{Exercice 1}
Avec la convention $0 \leftrightarrow \texttt{faux}$ et $1 \leftrightarrow \texttt{vrai}$, $0 \wedge 1 = \texttt{faux}$.

\subsection{Exercice 2}
On donne la table de $c_0$ :
\begin{center}
    $c_0 \colon$
    \begin{tabular}{||c | c | c ||} 
     \hline
     $a_0 \backslash b_0$ & 0 & 1 \\ [0.5ex] 
     \hline\hline
     0 & 0 & 1  \\ 
     \hline
     1 & 1 & 0 \\
     \hline
    \end{tabular}
\end{center}
On peut interpréter cette table comme la table de vérité du "ou exclusif", le \textit{xor}. Ainsi, $c_0$ coincide avec $a_0 \oplus b_0 = (a_0 \vee b_0) \wedge (\neg (a_0 \wedge b_0))$.

\subsection{Exercice 3}
a. Montrer que xor est associatif et commutatif puis recopier calcul\\

b. inclure schéma

\subsection{Exercice 4}
a. On écrit le code suivant :\\
\begin{lstlisting}[style=CStyle]
int main()
    {
        printf("Sizeof int: %lu octets\n", sizeof(int));
        printf("Sizeof short: %lu octets\n", sizeof(short));
        printf("Sizeof char: %lu octets\n", sizeof(char));
        return 0;
    }
\end{lstlisting}

La sortie est la suivante :\\
\begin{lstlisting}[frame = single]
    Sizeof int: 4 octets
    Sizeof short: 2 octets
    Sizeof char: 1 octets
\end{lstlisting}

b. On écrit le code suivant :
\begin{lstlisting}[style=CStyle]
int main()
    {
        int a = pow(2, 31);
        int b = pow(2, 31);
        int c = a + b;
        printf("%d\n", c);
        return 0;
    }
\end{lstlisting}

La sortie affiche 0, ce qui correspond bien à $2^{32} \mod(2^{32})$

\subsection{Exercice 5}
On donne ci-dessous l'écriture binaire sur 4 et 8 bits de 0, 1, -1 et -2:
\begin{center}
    \begin{tabular}{c | c | c} 
    $x$ & 4 bits & 8 bits\\
        \hline
        \hline
    0 :& 0000 & 0000 0000\\ 
    1 :& 0001 & 0000 0001\\
    -1 :& 1111 & 1111 1111\\
    -2 :& 1110 & 1111 1110\\
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. $m_1 = 0001$ et $m_{-1} = 1001$.

b. En abusant de la notation + pour des mots : $m_0 = m_1 + m_{-1} = 1010$.

c. En suivant la règle de signes, 1010 est l'encodage de -2.

\subsection{Exercice 7}
Soit $b$ un nombre de bits. Soit $x$ un entier relatif qu'on souhaite représenter sur $b$ bits.\\
Si $x \geq 0$, alors l'encodage de $x$ correspond à une écriture dans $[0, 2^{b-1}-1]$, alors cette écriture commence par un zéro (de 00...0 à 01...1). Si $x < 0$, alors $2^b - x \in [2^{b-1}, 2^b-1]$ (soit de 10...0 à 11...1), son écriture commence par un 1.


\subsection{Exercice 8}
Dans le premier code, on dispose de 2 cases mémoires différentes. Le résultat affiché est -106 pour la valeur de d, ce qui est normal puisque d est signé.\\
Dans le deuxième code, on utilise une seule case mémoire à travers l'utilisation de deux pointeurs, un signé et un non signé. Le résultat affiché est identique au premier code.\\
Cela permet de montrer que la mémoire est "non typée", l'interprétation de la valeur mémoire dépend directement du type de l'objet qui lit cette valeur.

\subsection{Exercice 9}
a. 10 s'écrit $2\times5$ et toute puissance de 2 s'écrit $2^k$ où $k\in \mathbb{N}$.\\
Ainsi, si $x \in 2^{\mathbb{N}}$ (par abus de langage) est divisible par 10, alors $x$ contient au moins 2 et 5 dans sa décomposition en facteurs premiers, ce qui donne une contradition avec la propriété précédemment énoncée.\\

b. Supposons que $0.1$ soit représentable sur $kl$ bits. Alors, d'après le résultat du cours, $2^l \times 0.1$ est un entier, autrement dit $2^l$ est divisible par 10. D'après la question précédente, c'est impossible.

\subsection{Exercice 10}
L'écriture binaire approchée de $0.1$ est $0.0001~1001_2$, de valeur décimale $0.09765625$.

\subsection{Exercice 11}

\end{document}