\documentclass[11pt, a4 paper]{article}
\usepackage[french]{babel}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multicol}
\usepackage{circuitikz}
\usetikzlibrary{babel}
\usetikzlibrary{backgrounds}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.92,0.92,0.95}

\newcommand{\halmos}{\hfill$\blacksquare$}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,     
    frame=single,    
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}


\begin{document}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .2\textwidth]{img/logoartem.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Architecture des ordinateurs}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Erwan LEBAILLY | Vilavane LY | Vincent TRÉLAT | Benjamin ZHU
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\tableofcontents
\pagebreak

\section{Chapitre 1}
\subsection{Exercice 1}
Avec la convention $0 \leftrightarrow \texttt{faux}$ et $1 \leftrightarrow \texttt{vrai}$, $0 \wedge 1 = \texttt{faux}$.

\subsection{Exercice 2}
On donne la table de $c_0$ :
\begin{center}
    $c_0 \colon$
    \begin{tabular}{||c | c | c ||} 
     \hline
     $a_0 \backslash b_0$ & 0 & 1 \\ [0.5ex] 
     \hline\hline
     0 & 0 & 1  \\ 
     \hline
     1 & 1 & 0 \\
     \hline
    \end{tabular}
\end{center}
On peut interpréter cette table comme la table de vérité du "ou exclusif", le \textit{xor}. Ainsi, $c_0$ coincide avec $a_0 \oplus b_0 = (a_0 \vee b_0) \wedge (\neg (a_0 \wedge b_0))$.

\subsection{Exercice 3}
a. Montrons que l'opérateur xor $\oplus$ est associatif et commutatif :\\
Soient $a, b, c \in \{0, 1\}$.\\

\textbf{Associativité :} on donne ci-dessous la table de vérité de $(a \oplus b) \oplus c$ et $a \oplus (b \oplus c)$:
\begin{center}
    \begin{tabular}{||c | c | c | c | c | c ||} 
     \hline
     $a$ & $b$ & $c$ & $a \oplus b$ & $(a \oplus b) \oplus c$ & $a \oplus (b \oplus c)$ \\ [0.5ex] 
     \hline\hline
    %a   b   c  a+b  r1 r2
     0 & 0 & 0 & 0 & 0 & 0\\ 
     0 & 0 & 1 & 0 & 1 & 1\\ 
     1 & 0 & 0 & 1 & 0 & 0\\ 
     1 & 0 & 1 & 1 & 0 & 0\\ 
     0 & 1 & 0 & 1 & 1 & 1\\ 
     0 & 1 & 1 & 1 & 0 & 0\\ 
     1 & 1 & 0 & 0 & 0 & 0\\ 
     1 & 1 & 1 & 0 & 1 & 1\\ 
     \hline
    \end{tabular}
\end{center}

\textbf{Commutativité :} on donne ci-dessous la table de vérité de $a \oplus b$ et $b \oplus a$:
\begin{center}
    \begin{tabular}{||c | c | c | c ||} 
     \hline
     $a$ & $b$ & $a \oplus b$ & $b \oplus a$ \\ [0.5ex] 
     \hline\hline
    %a   b  a+b  b+a
    0 & 0 & 0 & 0 \\
    0 & 1 & 1 & 1 \\
    1 & 0 & 1 & 1 \\
    1 & 1 & 0 & 0 \\
     \hline
    \end{tabular}
\end{center}

Enfin, $a \oplus a = 0$ et $a \oplus 0 = a$.\\

On peut maintenant montrer le résultat demandé :\\
\begin{equation*}
    d = a \oplus c = a \oplus (a \oplus b) = a \oplus a \oplus b = b
\end{equation*}

\begin{equation*}
    e = b \oplus c = b \oplus (a \oplus b) = b \oplus a \oplus b = a
\end{equation*}

\halmos

b. On donne ci-dessous le circuit correspondant :
\begin{center}
    \begin{circuitikz}[framed, scale=1.5]
        % \draw (0,0) node[ american and port ] {};
        % \draw (0,2) node[ american or port ] {};
        % \draw (0,6) node[ american not port ] {};
    
        \draw (0,1) node (a) {a};
        \draw (7,1) node (d) {d};
        \draw (0,-1) node (b) {b};
        \draw (7,-1) node (e) {e};
        \draw (3,0) node[ american xor port ] (xor1) {};
        \draw (6,1) node[ american xor port ] (xor2) {};
        \draw (6,-1) node[ american xor port ] (xor3) {};
        
        \draw (.2, 1) -- (xor1.in 1);
        \draw (.2, 1) -| (xor2.in 1);
        \draw (xor1.out) |- (xor2.in 2);
        \draw (xor1.out) |- (xor3.in 1);
        \draw (.2, -1) -- (xor1.in 2);
        \draw (.2, -1) -| (xor3.in 2);
        
        \draw (xor2.out) -| (6.8,1);
        \draw (xor3.out) -| (6.8,-1);
        
    \end{circuitikz}
\end{center}

\subsection{Exercice 4}
a. On écrit le code suivant :\\
\begin{lstlisting}[style=CStyle]
int main()
    {
        printf("Sizeof int: %lu octets\n", sizeof(int));
        printf("Sizeof short: %lu octets\n", sizeof(short));
        printf("Sizeof char: %lu octets\n", sizeof(char));
        return 0;
    }
\end{lstlisting}

La sortie est la suivante :\\
\begin{lstlisting}[style=CStyle]
    Sizeof int: 4 octets
    Sizeof short: 2 octets
    Sizeof char: 1 octets
\end{lstlisting}

b. On écrit le code suivant :
\begin{lstlisting}[style=CStyle]
int main()
    {
        int a = pow(2, 31);
        int b = pow(2, 31);
        int c = a + b;
        printf("%d\n", c);
        return 0;
    }
\end{lstlisting}

La sortie affiche 0, ce qui correspond bien à $2^{32} \mod(2^{32})$

\subsection{Exercice 5}
On donne ci-dessous l'écriture binaire sur 4 et 8 bits de 0, 1, -1 et -2:
\begin{center}
    \begin{tabular}{c | c | c} 
    $x$ & 4 bits & 8 bits\\
        \hline
        \hline
    0 :& 0000 & 0000 0000\\ 
    1 :& 0001 & 0000 0001\\
    -1 :& 1111 & 1111 1111\\
    -2 :& 1110 & 1111 1110\\
     \hline
    \end{tabular}
\end{center}

\subsection{Exercice 6}
a. $m_1 = 0001$ et $m_{-1} = 1001$.

b. En abusant de la notation + pour des mots : $m_0 = m_1 + m_{-1} = 1010$.

c. En suivant la règle de signes, 1010 est l'encodage de -2.

\subsection{Exercice 7}
Soit $b$ un nombre de bits. Soit $x$ un entier relatif qu'on souhaite représenter sur $b$ bits.\\
Si $x \geq 0$, alors l'encodage de $x$ correspond à une écriture dans $[0, 2^{b-1}-1]$, alors cette écriture commence par un zéro (de 00...0 à 01...1). Si $x < 0$, alors $2^b - x \in [2^{b-1}, 2^b-1]$ (soit de 10...0 à 11...1), son écriture commence par un 1.

\halmos


\subsection{Exercice 8}
Dans le premier code, on dispose de 2 cases mémoires différentes. Le résultat affiché est -106 pour la valeur de d, ce qui est normal puisque d est signé.\\
Dans le deuxième code, on utilise une seule case mémoire à travers l'utilisation de deux pointeurs, un signé et un non signé. Le résultat affiché est identique au premier code.\\
Cela permet de montrer que la mémoire est "non typée", l'interprétation de la valeur mémoire dépend directement du type de l'objet qui lit cette valeur.

\subsection{Exercice 9}
a. 10 s'écrit $2\times5$ et toute puissance de 2 s'écrit $2^k$ où $k\in \mathbb{N}$.\\
Ainsi, si $x \in 2^{\mathbb{N}}$ (par abus de langage) est divisible par 10, alors $x$ contient au moins 2 et 5 dans sa décomposition en facteurs premiers, ce qui donne une contradition avec la propriété précédemment énoncée.\\

\halmos

b. Supposons que $0.1$ soit représentable sur $kl$ bits. Alors, d'après le résultat du cours, $2^l \times 0.1$ est un entier, autrement dit $2^l$ est divisible par 10. D'après la question précédente, c'est impossible.

\halmos

\subsection{Exercice 10}
L'écriture binaire approchée de $0.1$ est $0.0001~1001_2$, de valeur décimale $0.09765625$.

\subsection{Exercice 11}
a. On écrit la fonction suivante en C :

\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            printf("(%d, %d) : %s\n", i, j, (a+b == c)?"true":"false");
        }
    } 
    return 0;
}
\end{lstlisting}

La sortie affichée contient, entre autres, les résultats suivants :
\begin{multicols}{2}
    \begin{itemize}
        \item[$\bullet$] (1, 4) : true
        \item[$\bullet$] (1, 5) : true
        \item[$\bullet$] (1, 6) : false
        \item[$\bullet$] (1, 7) : true
        \item[$\bullet$] (1, 8) : false
        
        \item[$\bullet$] (3, 4) : false
        \item[$\bullet$] (3, 5) : true
        \item[$\bullet$] (3, 6) : false
        \item[$\bullet$] (3, 7) : true
        \item[$\bullet$] (3, 8) : true
    \end{itemize}    
\end{multicols}

b. On modifie seulement la ligne d'affichage dans le code\footnote{Comme un \texttt{int} est codé sur 4 octets, on donne 16 caractères à chaque affichage.} :
\begin{lstlisting}[style=CStyle]
printf("%.16f + %.16f = %.16f\n", a, b, c);
\end{lstlisting}
On donne seulement les résultats pour les 5 premiers couples ci-dessus :
\begin{lstlisting}[style=CStyle]
0.1000000014901161 + 0.4000000059604645 = 0.5000000000000000
0.1000000014901161 + 0.5000000000000000 = 0.6000000238418579
0.1000000014901161 + 0.6000000238418579 = 0.6999999880790710
0.1000000014901161 + 0.6999999880790710 = 0.8000000119209290
0.1000000014901161 + 0.8000000119209290 = 0.8999999761581421
\end{lstlisting}

c. On remarque que pour une addition, l'égalité \texttt{a+b==c} est vérifiée lorsque \texttt{a} et \texttt{b} sont représentables, ou quand l'un des deux seulement l'est. Dans le second cas, l'erreur de représentation n'a pas eu d'impact sur le résultat puisque c'est la seule erreur du calcul. Ainsi l'égalité reste vraie.\\
En revanche, dès que les deux flottants ne sont pas représentables, les erreurs s'accumulent et alors la représentation de \texttt{c} peut différer de la valeur de \texttt{a+b}.\\

Dans un cas général si on prend $x, y \in \mathbb{R}$ tels que $x=y$, on aura \texttt{x==y} quand $x$ et $y$ sont représentables sur un nombre de bits donné\footnote{Il faut tout de même faire attention à la précision. Augmenter la précision ne rendra pas les calculs exacts pour autant.}. Dans les autres cas, il est possible d'obtenir un résultat correct mais cela résulte plutôt du hasard.\\

d. On modifie la fonction précédente :
\begin{lstlisting}[style=CStyle]
int main() {
    for (int i = 0; i<10; i++){
        for (int j = 0; j < 10; j++){
            float a = i/10.0, b = j/10.0, c = (i+j)/10.0;
            if(a+b!=c){
                int m1 = a+b>c;
                int m2 = a+b+.000001>c+.000001;
                printf("(%d, %d) : %d %d\n", i, j, m1, m2);
            }
        }
    } 
    return 0;
}
\end{lstlisting}

On obtient la sortie suivante :
\begin{lstlisting}[style=CStyle]
// a+b > c is tested before and after adding 1e-6
(1, 6) : 1 1
(1, 8) : 1 1
(3, 4) : 1 1
(3, 6) : 1 1
(4, 3) : 1 1
(6, 1) : 1 1
(6, 3) : 1 1
(6, 8) : 1 1
(7, 9) : 0 0
(8, 1) : 1 1
(8, 6) : 1 1
(9, 7) : 0 0
\end{lstlisting}
On constate que l'ordre est conservé à chaque fois. Comme $10^{-6}$ n'est pas représentable sur 16 bits ($10^{-6} \approx 2^{-20}$), on simule l'effet de la propagation d'une erreur.\\
On en déduit que des erreurs successives d'arrondi ne bousculent pas l'ordre sur des valeurs arrondies. Toutefois ici on effectue le même calcul des deux côtés. On peut donc toujours les comparer\footnote{Pas l'égalité.}, même après plusieurs calculs, puisque l'ordre est conservé. On peut également penser que cela ne provoquera pas d'évolution chaotique ou aléatoire de ces valeurs dans les calculs. En revanche, pour une suite d'opérations inconnue, cela risque de devenir insignifiant de vouloir comparer deux flottants.

\subsection{Exercice 12}
On note $s_1 = \displaystyle{\sum_{i=1}^{k} \frac{1}{i}}$ et $s_2 = \displaystyle{\sum_{i=k}^{1} \frac{1}{i}}$.\\
On écrit la fonction suivante :

\begin{lstlisting}[style=CStyle]
int main() {
    float s1 = 0.0, s2 = 0.0;
    long k = 1000000000;
    for (double i = 1; i<k+1; i++){
        s1 += 1/i;
        s2 += 1/(k+1-i);
    }
    printf("k=%ld\n    s1 = %.16f\n    s2 = %.16f\n", k, s1, s2);
    return 0;
}
\end{lstlisting}

Les résultats sont les suivants :
\begin{lstlisting}[style=CStyle]
k=1000
    s1 = 7.4854784011840820
    s2 = 7.4854717254638672
k=1000000
    s1 = 14.3573579788208008
    s2 = 14.3926515579223633
k=1000000000
    s1 = 15.4036827087402344
    s2 = 18.8079185485839844
\end{lstlisting}
On constate que les résultats diffèrent\footnote{Même plus que ça, on dirait que la série converge ! On connait l'équivalent pour la série harmonique : $H_n \underset{n \to +\infty}{\sim} \gamma + \ln(n)$ où $\gamma \approx 0.5$ est la constante d'Euler. Pour $n = 10^9$, on devrait donc plutôt être autour de $H_n \approx 21$.} d'autant plus que le nombre d'erreurs successives est grand, ce qui n'est pas étonnant. Là où le résultat interpelle, c'est que l'ordre de parcours de la somme a un impact conséquent sur le résultat.\\
Cette erreur est due au fait que lorsque le parcours est décroissant, on finit pas les petits nombres. Ces derniers causent alors des erreurs d'arrondi car leur ordre de grandeur est faible par rapport aux premiers nombres.

\subsection{Exercice 13}
a. La taille d'un \texttt{float} en C est de 4 \textit{bytes}, soit 32 bits :
\begin{itemize}
    \item[$\bullet$] 1 bit de signe
    \item[$\bullet$] 8 bits d'exposant
    \item[$\bullet$] 23 bits de mantisse
\end{itemize}

b. Convertissons d'abord \texttt{0x414BD000} en binaire :
\begin{equation*}
    414BD000_{16} = 01000001010010111101000000000000_2
\end{equation*}
On identifie ensuite les bits de signe, d'exposant et de mantisse :
\begin{equation*}
    \underset{S}{\underbrace{0}}~\underset{E=130}{\underbrace{10000010}}~\underset{T}{\underbrace{10010111101000000000000}}
\end{equation*}
Le biais $b$ valant 127, notre exposant ici vaut $E-b = 3$. Donc, en "écriture binaire à virgule", on obtient :
\begin{equation*}
    1.10010111101 \times 2^3 = \underset{=12}{\underbrace{1100}}.\underset{=0.73828125}{\underbrace{10111101}}
\end{equation*}
Soit finalement :
\begin{center}
    \texttt{0x414BD000}$_{16}$ encode $12.73828125$
\end{center}

c. En suivant le raisonnement inverse, on peut trouver l'exposant et la mantisse de l'encodage de 0.1. On commence par l'écrire en "binaire à virgule" :
\begin{equation*}
    0.1 = 000110011001100110011001101_2
\end{equation*}
On décale la virgule pour trouver l'exposant :
\begin{equation*}
    0.1 = 1.10011001100110011001101_2 \times 2^{-4}
\end{equation*}
Cela donne donc un exposant de $E = b - 4 = 123 = 01111011_2$ sur 8 bits. Enfin, $0.1 > 0$ donc on met un premier bit à 0. On obtient donc l'encodage suivant -- dont on donne également la valeur décimale réelle -- pour le nombre 0.1 :
\begin{equation*}
    \underset{\text{signe}}{\underbrace{0}}\underset{\text{exposant}}{\underbrace{01111011}}\underset{\text{mantisse}}{\underbrace{10011001100110011001101_2}} = 0.100000001490116119384765625
\end{equation*}

\section{Chapitre 2}
\subsection{Exercice 1}
a. Lorsqu'on crée par exemple un tableau de taille un milliard, on obtient une erreur similaire à la suivante :
\begin{lstlisting}[style=CStyle]
[1]    54133 segmentation fault  ./a.out
\end{lstlisting}
b. En expérimentant à la main, on trouve qu'on peut créer un tableau de taille maximale 2 096 286.

\subsection{Exercice 2}
On vérifie par exemple qu'on peut créer un tableau de taille un milliard.

\subsection{Exercice 3}
La machine utilisée pour ce TD utilise la convention \textit{little endian}.

\subsection{Exercice 4}
On écrit déjà le code suivant :
\begin{lstlisting}[style=CStyle]
#include <stdio.h>
#include <x86intrin.h>

unsigned long int squareSum(int n){
        unsigned long int tic,toc;
        unsigned int ui;
        int a = 0;
        tic = __rdtscp(&ui);
        for (int i=0; i < n; ++i){
            a = a*a+a*a;
        }
        toc = __rdtscp(&ui);
        return toc-tic;
    }

int main(){
    printf("n=%d: %lu tics\n", 1000, squareSum(1000));
    printf("n=%d: %lu tics\n", 10000, squareSum(10000));
    printf("n=%d: %lu tics\n", 1000000, squareSum(1000000));
    printf("n=%d: %lu tics\n", 10000000, squareSum(10000000));
    printf("n=%d: %lu tics\n", 100000000, squareSum(100000000));
    return 0;
}
\end{lstlisting}
On obtient les résultats suivants:
\begin{center}
    \begin{tabular}{| c || c | c | c | c | c |}
        \hline
    $n$ & $10^3$ & $10^4$ & $10^6$ & $10^7$ & $10^8$ \\
        \hline
    mesure & 7956 & 75350 & 7681712 & 70013740 & 534394538\\ 
     \hline
    \end{tabular}
\end{center}
On note qu'on semble bien obtenir une relation qui a l'air linéaire, hormis la dernière mesure.

\subsection{Exercice 5}
\subsection{Exercice 6}
\subsection{Exercice 7}
\subsection{Exercice 8}

\end{document}